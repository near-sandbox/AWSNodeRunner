"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearInfrastructureStack = void 0;
const cdk = __importStar(require("aws-cdk-lib"));
const ec2 = __importStar(require("aws-cdk-lib/aws-ec2"));
const nag = __importStar(require("cdk-nag"));
class NearInfrastructureStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const REGION = cdk.Stack.of(this).region;
        const STACK_NAME = cdk.Stack.of(this).stackName;
        const STACK_ID = cdk.Stack.of(this).stackId;
        const { instanceType, instanceCpuType, nearNetwork, nearVersion, dataVolume, vpc, securityGroup, instanceRole, } = props;
        // Use provided VPC/security group/role or import from common stack
        if (vpc && securityGroup && instanceRole) {
            this.vpc = vpc;
            this.securityGroup = securityGroup;
            this.instanceRole = instanceRole;
        }
        else {
            // Fallback to imports (for cross-stack references when stacks are in different apps)
            const vpcId = cdk.Fn.importValue("NearLocalnetVpcId");
            const securityGroupId = cdk.Fn.importValue("NearLocalnetSecurityGroupId");
            const importedInstanceRoleArn = cdk.Fn.importValue("NearLocalnetInstanceRoleArn");
            // Note: Vpc.fromLookup requires environment context and won't work with imported values
            // This fallback is for reference but should use direct references in app.ts
            throw new Error("VPC, security group, and instance role must be provided directly when stacks are in the same app");
        }
        // Ubuntu 24.04 LTS image for amd64 (x86_64 required for NEAR)
        let ubuntuStableImageSsmName = "/aws/service/canonical/ubuntu/server/24.04/stable/current/amd64/hvm/ebs-gp3/ami-id";
        if (instanceCpuType === "arm64") {
            ubuntuStableImageSsmName = "/aws/service/canonical/ubuntu/server/24.04/stable/current/arm64/hvm/ebs-gp3/ami-id";
        }
        const machineImage = ec2.MachineImage.fromSsmParameter(ubuntuStableImageSsmName);
        // Parse instance type - CDK expects InstanceClass enum and InstanceSize enum
        // "t3.large" -> InstanceClass.T3, InstanceSize.LARGE
        const [instanceClassStr, instanceSizeStr] = instanceType.toLowerCase().split(".");
        // Convert "t3" -> "T3" for InstanceClass enum
        const instanceClass = (instanceClassStr.charAt(0).toUpperCase() + instanceClassStr.slice(1)).toUpperCase();
        const instanceSize = instanceSizeStr.toUpperCase();
        const ec2InstanceType = new ec2.InstanceType(`${instanceClassStr}.${instanceSizeStr}`);
        // UserData script following the working implementation from chain-mobil/cdk
        // This compiles and runs neard on Ubuntu per NEAR's recommendations
        // Modified to add localnet root account to genesis for .localnet naming parity
        // Force replacement: 2025-12-30T05:35:00Z
        const userData = ec2.UserData.forLinux();
        userData.addCommands('#!/bin/bash', 'set -e', 'exec > >(tee /var/log/near-setup.log) 2>&1', '', '# Force replacement timestamp: 2025-12-30T05:35:00Z', '', '# Update system', 'apt update', '', '# Install dependencies for NEAR compilation (Ubuntu packages)', 
        // NOTE: Ubuntu 24.04 no longer provides an `awscli` apt candidate in some images/repos.
        // Install AWS CLI via pip below.
        'apt install -y git binutils-dev libcurl4-openssl-dev zlib1g-dev libdw-dev libiberty-dev cmake gcc g++ python3 python3-pip protobuf-compiler libssl-dev pkg-config clang llvm jq', '', '# Install Rust as ubuntu user', 'su - ubuntu -c "curl --proto =https --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"', 'su - ubuntu -c "source ~/.cargo/env && rustc --version"', '', '# Clone nearcore', 'su - ubuntu -c "cd ~ && git clone https://github.com/near/nearcore.git"', `su - ubuntu -c "cd ~/nearcore && git checkout ${nearVersion}"`, '', '# Compile neard (takes ~10-15 minutes)', 'su - ubuntu -c "cd ~/nearcore && source ~/.cargo/env && make neard"', '', '# Install nearup (Ubuntu 24.04 requires --break-system-packages)', 'su - ubuntu -c "pip3 install --user --break-system-packages nearup"', '', '# Install AWS CLI (required for writing SSM parameters during bootstrap)', 'pip3 install --break-system-packages awscli', 'aws --version || true', '', '# Run nearup localnet with compiled binary (creates genesis.json)', 'su - ubuntu -c "export PATH=$PATH:~/.local/bin && nearup run localnet --binary-path ~/nearcore/target/release" > /var/log/nearup.log 2>&1 &', '', '# Wait for genesis.json to be created by nearup', 'echo "Waiting for genesis.json to be created..."', 'for i in {1..60}; do', '  if [ -f /home/ubuntu/.near/localnet/node0/genesis.json ]; then', '    echo "Genesis file found"', '    break', '  fi', '  sleep 2', 'done', '', '# Stop nearup and all neard processes before patching genesis', 'echo "Stopping nearup and neard processes..."', 'su - ubuntu -c "pkill -f nearup || true"', 'su - ubuntu -c "pkill -f neard || true"', 'sleep 5', '', '# Generate localnet keypair using neard init (works in neard 2.10.1)', 'echo "Generating localnet keypair using neard init..."', 'su - ubuntu -c "rm -rf ~/.near/localnet-keygen && mkdir -p ~/.near/localnet-keygen"', 'su - ubuntu -c "~/nearcore/target/release/neard --home ~/.near/localnet-keygen init --account-id localnet --chain-id localnet --fast"', '', '# Extract public and secret keys from validator_key.json', 'LOCALNET_KEY_FILE="/home/ubuntu/.near/localnet-keygen/validator_key.json"', 'if [ ! -f "$LOCALNET_KEY_FILE" ]; then', '  echo "ERROR: validator_key.json not found after neard init"', '  exit 1', 'fi', 'LOCALNET_PUBLIC_KEY=$(su - ubuntu -c "cat $LOCALNET_KEY_FILE | jq -r \'.public_key\'" 2>/dev/null || echo "")', 'LOCALNET_SECRET_KEY=$(su - ubuntu -c "cat $LOCALNET_KEY_FILE | jq -r \'.secret_key\'" 2>/dev/null || echo "")', '', 'if [ -z "$LOCALNET_PUBLIC_KEY" ] || [ -z "$LOCALNET_SECRET_KEY" ] || [ "$LOCALNET_PUBLIC_KEY" = "null" ] || [ "$LOCALNET_SECRET_KEY" = "null" ]; then', '  echo "ERROR: Could not extract localnet keys from validator_key.json"', '  exit 1', 'fi', '', '# Create Python script for genesis patching with reallocation', 'cat > /tmp/patch-genesis-localnet.py << \'PYEOF\'', '#!/usr/bin/env python3', 'import json', 'import sys', '', 'if len(sys.argv) != 5:', '    print("Usage: patch-genesis-localnet.py <genesis.json> <public_key> <transfer_amount> <output.json>")', '    sys.exit(1)', '', 'genesis_path = sys.argv[1]', 'public_key = sys.argv[2]', 'transfer_amount = sys.argv[3]', 'output_path = sys.argv[4]', '', 'with open(genesis_path, \'r\') as f:', '    genesis = json.load(f)', '', '# Find node0 Account record and subtract transfer_amount', 'node0_found = False', 'for record in genesis.get(\'records\', []):', '    if \'Account\' in record:', '        account = record[\'Account\']', '        if account.get(\'account_id\') == \'node0\':', '            node0_found = True', '            current_amount = int(account[\'account\'][\'amount\'])', '            new_amount = current_amount - int(transfer_amount)', '            if new_amount < 0:', '                print(f"ERROR: node0 balance ({current_amount}) insufficient for transfer ({transfer_amount})")', '                sys.exit(1)', '            account[\'account\'][\'amount\'] = str(new_amount)', '            print(f"Reallocated {transfer_amount} yoctoNEAR from node0 (new balance: {new_amount})")', '            break', '', 'if not node0_found:', '    print("ERROR: node0 Account record not found in genesis")', '    sys.exit(1)', '', '# Add localnet Account record', 'localnet_account_record = {', '    "Account": {', '        "account_id": "localnet",', '        "account": {', '            "amount": transfer_amount,', '            "locked": "0",', '            "code_hash": "11111111111111111111111111111111",', '            "storage_usage": 182,', '            "version": "V1"', '        }', '    }', '}', 'genesis[\'records\'].append(localnet_account_record)', '', '# Add localnet AccessKey record', 'localnet_access_key_record = {', '    "AccessKey": {', '        "account_id": "localnet",', '        "public_key": public_key,', '        "access_key": {', '            "nonce": 0,', '            "permission": "FullAccess"', '        }', '    }', '}', 'genesis[\'records\'].append(localnet_access_key_record)', '', 'with open(output_path, \'w\') as f:', '    json.dump(genesis, f, indent=2)', '', 'print(f"Genesis patched successfully: {output_path}")', 'PYEOF', 'chmod +x /tmp/patch-genesis-localnet.py', '', '# Patch genesis.json with reallocation from node0', 'echo "Patching genesis.json with localnet account (reallocating from node0)..."', 'GENESIS_PATH="/home/ubuntu/.near/localnet/node0/genesis.json"', 'AMOUNT="100000000000000000000000000000"  # 100,000 NEAR', '', '# Backup genesis', 'su - ubuntu -c "cp $GENESIS_PATH ${GENESIS_PATH}.backup.$(date +%s)"', '', '# Run Python script to patch genesis', 'python3 /tmp/patch-genesis-localnet.py "$GENESIS_PATH" "$LOCALNET_PUBLIC_KEY" "$AMOUNT" /tmp/genesis_patched.json', '', '# Replace genesis for all nodes', 'for node in node0 node1 node2 node3; do', '  if [ -d /home/ubuntu/.near/localnet/$node ]; then', '    su - ubuntu -c "cp /tmp/genesis_patched.json /home/ubuntu/.near/localnet/$node/genesis.json"', '    echo "Updated genesis for $node"', '  fi', 'done', '', '# Remove node data directories so nodes start cleanly with patched genesis', 'echo "Removing node data directories for clean start..."', 'for node in node0 node1 node2 node3; do', '  if [ -d /home/ubuntu/.near/localnet/$node/data ]; then', '    su - ubuntu -c "rm -rf /home/ubuntu/.near/localnet/$node/data"', '    echo "Removed data directory for $node"', '  fi', 'done', '', '# Store localnet keypair in SSM Parameter Store', 'echo "Storing localnet keypair in SSM..."', '# IMDSv2-safe region discovery', 'TOKEN=$(curl -sS -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" || true)', 'if [ -n "$TOKEN" ]; then', '  AWS_REGION=$(curl -sS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)', 'else', '  AWS_REGION=$(curl -sS http://169.254.169.254/latest/meta-data/placement/region)', 'fi', 'aws ssm put-parameter --name "/near-localnet/localnet-account-key" --value "$LOCALNET_SECRET_KEY" --type "SecureString" --overwrite --region "$AWS_REGION" || true', 'aws ssm put-parameter --name "/near-localnet/localnet-account-id" --value "localnet" --type "String" --overwrite --region "$AWS_REGION" || true', 'echo "Localnet keypair stored in SSM"', '', '# Start neard processes directly (not via nearup)', 'echo "Starting neard processes with patched genesis..."', '# Get node0 boot node public key', 'BOOT_PUB=$(su - ubuntu -c "cat ~/.near/localnet/node0/node_key.json | jq -r \'.public_key\'")', 'BOOT_NODE="${BOOT_PUB}@127.0.0.1:24567"', '', '# Start node0', 'su - ubuntu -c "nohup ~/nearcore/target/release/neard --home ~/.near/localnet/node0 run > ~/neard-node0.log 2>&1 &"', 'sleep 2', '', '# Start node1, node2, node3 with boot node', 'for i in 1 2 3; do', '  su - ubuntu -c "nohup ~/nearcore/target/release/neard --home ~/.near/localnet/node$i run --boot-nodes $BOOT_NODE > ~/neard-node$i.log 2>&1 &"', 'done', '', '# Wait for nodes to initialize', 'sleep 10', '', '# Validation: Check RPC status', 'echo "Validating NEAR node startup..."', 'for i in {1..30}; do', '  if curl -sS http://127.0.0.1:3030/status > /dev/null 2>&1; then', '    echo "RPC endpoint responding"', '    break', '  fi', '  if [ $i -eq 30 ]; then', '    echo "WARNING: RPC endpoint not responding after 30 attempts"', '  fi', '  sleep 2', 'done', '', '# Validation: Verify localnet account exists in genesis', 'if grep -q "\\"account_id\\": \\"localnet\\"" /home/ubuntu/.near/localnet/node0/genesis.json; then', '  echo "✅ Genesis contains localnet account"', 'else', '  echo "❌ ERROR: Genesis does not contain localnet account"', '  exit 1', 'fi', '', 'echo "NEAR localnet initialization complete with localnet root account" > /var/log/near-init-complete.log');
        // Create EC2 instance (following working chain-mobil implementation)
        // Changed ID to force replacement when version updates
        // Added timestamp suffix to force new instance creation for genesis modification
        this.instance = new ec2.Instance(this, `NearLocalnetNodeV${nearVersion.replace(/\./g, "")}Localnet`, {
            vpc: this.vpc,
            instanceType: ec2InstanceType,
            machineImage,
            securityGroup: this.securityGroup,
            role: this.instanceRole,
            userData, // Set UserData directly (following working chain-mobil implementation)
            vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC }, // For outbound internet (download Rust, nearcore)
            ssmSessionPermissions: true, // Enable SSM Session Manager
            // Increase root volume size for Rust compilation (default 8GB is too small)
            blockDevices: [{
                    deviceName: "/dev/sda1", // Ubuntu root device
                    volume: ec2.BlockDeviceVolume.ebs(dataVolume.sizeGiB, {
                        volumeType: ec2.EbsDeviceVolumeType.GP3,
                        deleteOnTermination: true,
                    }),
                }],
        });
        // Store the logical ID for cfn-signal
        const nodeCFLogicalId = this.instance.node.defaultChild?.node.id || "NearLocalnetNode";
        // Add version tag to force replacement when version changes
        cdk.Tags.of(this.instance).add("NearVersion", nearVersion);
        this.instanceId = this.instance.instanceId;
        // Stack outputs
        new cdk.CfnOutput(this, "near-instance-id", {
            value: this.instanceId,
            exportName: "NearLocalnetInstanceId",
        });
        new cdk.CfnOutput(this, "near-instance-private-ip", {
            value: this.instance.instancePrivateIp,
            exportName: "NearLocalnetInstancePrivateIp",
        });
        new cdk.CfnOutput(this, "near-instance-public-ip", {
            value: this.instance.instancePublicIp || "N/A",
            exportName: "NearLocalnetInstancePublicIp",
        });
        // Adding suppressions to the stack
        nag.NagSuppressions.addResourceSuppressions(this, [
            {
                id: "AwsSolutions-EC23",
                reason: "SSH access needed for debugging, RPC restricted to VPC",
            },
            {
                id: "AwsSolutions-EC26",
                reason: "EBS encryption not required for localnet development environment",
            },
            {
                id: "AwsSolutions-EC28",
                reason: "Detailed monitoring not required for localnet development environment",
            },
            {
                id: "AwsSolutions-EC29",
                reason: "Termination protection not required for localnet development environment",
            },
        ], true);
    }
}
exports.NearInfrastructureStack = NearInfrastructureStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5mcmFzdHJ1Y3R1cmUtc3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmZyYXN0cnVjdHVyZS1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpREFBbUM7QUFFbkMseURBQTJDO0FBRTNDLDZDQUErQjtBQWUvQixNQUFhLHVCQUF3QixTQUFRLEdBQUcsQ0FBQyxLQUFLO0lBT2xELFlBQVksS0FBOEIsRUFBRSxFQUFVLEVBQUUsS0FBbUM7UUFDdkYsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3pDLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNoRCxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFFNUMsTUFBTSxFQUNGLFlBQVksRUFDWixlQUFlLEVBQ2YsV0FBVyxFQUNYLFdBQVcsRUFDWCxVQUFVLEVBQ1YsR0FBRyxFQUNILGFBQWEsRUFDYixZQUFZLEdBQ2YsR0FBRyxLQUFLLENBQUM7UUFFVixtRUFBbUU7UUFDbkUsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQ2YsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7WUFDbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDckMsQ0FBQzthQUFNLENBQUM7WUFDSixxRkFBcUY7WUFDckYsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUN0RCxNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sdUJBQXVCLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsNkJBQTZCLENBQUMsQ0FBQztZQUVsRix3RkFBd0Y7WUFDeEYsNEVBQTRFO1lBQzVFLE1BQU0sSUFBSSxLQUFLLENBQUMsa0dBQWtHLENBQUMsQ0FBQztRQUN4SCxDQUFDO1FBRUQsOERBQThEO1FBQzlELElBQUksd0JBQXdCLEdBQUcsb0ZBQW9GLENBQUM7UUFDcEgsSUFBSSxlQUFlLEtBQUssT0FBTyxFQUFFLENBQUM7WUFDOUIsd0JBQXdCLEdBQUcsb0ZBQW9GLENBQUM7UUFDcEgsQ0FBQztRQUNELE1BQU0sWUFBWSxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUVqRiw2RUFBNkU7UUFDN0UscURBQXFEO1FBQ3JELE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLENBQUMsR0FBRyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xGLDhDQUE4QztRQUM5QyxNQUFNLGFBQWEsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQXVCLENBQUM7UUFDaEksTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBc0IsQ0FBQztRQUN2RSxNQUFNLGVBQWUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxnQkFBZ0IsSUFBSSxlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBRXZGLDRFQUE0RTtRQUM1RSxvRUFBb0U7UUFDcEUsK0VBQStFO1FBQy9FLDBDQUEwQztRQUMxQyxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pDLFFBQVEsQ0FBQyxXQUFXLENBQ2hCLGFBQWEsRUFDYixRQUFRLEVBQ1IsNENBQTRDLEVBQzVDLEVBQUUsRUFDRixxREFBcUQsRUFDckQsRUFBRSxFQUNGLGlCQUFpQixFQUNqQixZQUFZLEVBQ1osRUFBRSxFQUNGLCtEQUErRDtRQUMvRCx3RkFBd0Y7UUFDeEYsaUNBQWlDO1FBQ2pDLGlMQUFpTCxFQUNqTCxFQUFFLEVBQ0YsK0JBQStCLEVBQy9CLHdGQUF3RixFQUN4Rix5REFBeUQsRUFDekQsRUFBRSxFQUNGLGtCQUFrQixFQUNsQix5RUFBeUUsRUFDekUsaURBQWlELFdBQVcsR0FBRyxFQUMvRCxFQUFFLEVBQ0Ysd0NBQXdDLEVBQ3hDLHFFQUFxRSxFQUNyRSxFQUFFLEVBQ0Ysa0VBQWtFLEVBQ2xFLHFFQUFxRSxFQUNyRSxFQUFFLEVBQ0YsMEVBQTBFLEVBQzFFLDZDQUE2QyxFQUM3Qyx1QkFBdUIsRUFDdkIsRUFBRSxFQUNGLG1FQUFtRSxFQUNuRSw2SUFBNkksRUFDN0ksRUFBRSxFQUNGLGlEQUFpRCxFQUNqRCxrREFBa0QsRUFDbEQsc0JBQXNCLEVBQ3RCLGtFQUFrRSxFQUNsRSwrQkFBK0IsRUFDL0IsV0FBVyxFQUNYLE1BQU0sRUFDTixXQUFXLEVBQ1gsTUFBTSxFQUNOLEVBQUUsRUFDRiwrREFBK0QsRUFDL0QsK0NBQStDLEVBQy9DLDBDQUEwQyxFQUMxQyx5Q0FBeUMsRUFDekMsU0FBUyxFQUNULEVBQUUsRUFDRixzRUFBc0UsRUFDdEUsd0RBQXdELEVBQ3hELHFGQUFxRixFQUNyRix1SUFBdUksRUFDdkksRUFBRSxFQUNGLDBEQUEwRCxFQUMxRCwyRUFBMkUsRUFDM0Usd0NBQXdDLEVBQ3hDLCtEQUErRCxFQUMvRCxVQUFVLEVBQ1YsSUFBSSxFQUNKLCtHQUErRyxFQUMvRywrR0FBK0csRUFDL0csRUFBRSxFQUNGLHVKQUF1SixFQUN2Six5RUFBeUUsRUFDekUsVUFBVSxFQUNWLElBQUksRUFDSixFQUFFLEVBQ0YsK0RBQStELEVBQy9ELG1EQUFtRCxFQUNuRCx3QkFBd0IsRUFDeEIsYUFBYSxFQUNiLFlBQVksRUFDWixFQUFFLEVBQ0Ysd0JBQXdCLEVBQ3hCLDJHQUEyRyxFQUMzRyxpQkFBaUIsRUFDakIsRUFBRSxFQUNGLDRCQUE0QixFQUM1QiwwQkFBMEIsRUFDMUIsK0JBQStCLEVBQy9CLDJCQUEyQixFQUMzQixFQUFFLEVBQ0Ysc0NBQXNDLEVBQ3RDLDRCQUE0QixFQUM1QixFQUFFLEVBQ0YsMERBQTBELEVBQzFELHFCQUFxQixFQUNyQiw2Q0FBNkMsRUFDN0MsK0JBQStCLEVBQy9CLHVDQUF1QyxFQUN2QyxzREFBc0QsRUFDdEQsZ0NBQWdDLEVBQ2hDLG9FQUFvRSxFQUNwRSxnRUFBZ0UsRUFDaEUsZ0NBQWdDLEVBQ2hDLGlIQUFpSCxFQUNqSCw2QkFBNkIsRUFDN0IsZ0VBQWdFLEVBQ2hFLHNHQUFzRyxFQUN0RyxtQkFBbUIsRUFDbkIsRUFBRSxFQUNGLHFCQUFxQixFQUNyQiwrREFBK0QsRUFDL0QsaUJBQWlCLEVBQ2pCLEVBQUUsRUFDRiwrQkFBK0IsRUFDL0IsNkJBQTZCLEVBQzdCLGtCQUFrQixFQUNsQixtQ0FBbUMsRUFDbkMsc0JBQXNCLEVBQ3RCLHdDQUF3QyxFQUN4Qyw0QkFBNEIsRUFDNUIsOERBQThELEVBQzlELG1DQUFtQyxFQUNuQyw2QkFBNkIsRUFDN0IsV0FBVyxFQUNYLE9BQU8sRUFDUCxHQUFHLEVBQ0gsc0RBQXNELEVBQ3RELEVBQUUsRUFDRixpQ0FBaUMsRUFDakMsZ0NBQWdDLEVBQ2hDLG9CQUFvQixFQUNwQixtQ0FBbUMsRUFDbkMsbUNBQW1DLEVBQ25DLHlCQUF5QixFQUN6Qix5QkFBeUIsRUFDekIsd0NBQXdDLEVBQ3hDLFdBQVcsRUFDWCxPQUFPLEVBQ1AsR0FBRyxFQUNILHlEQUF5RCxFQUN6RCxFQUFFLEVBQ0YscUNBQXFDLEVBQ3JDLHFDQUFxQyxFQUNyQyxFQUFFLEVBQ0YsdURBQXVELEVBQ3ZELE9BQU8sRUFDUCx5Q0FBeUMsRUFDekMsRUFBRSxFQUNGLG1EQUFtRCxFQUNuRCxpRkFBaUYsRUFDakYsK0RBQStELEVBQy9ELHlEQUF5RCxFQUN6RCxFQUFFLEVBQ0Ysa0JBQWtCLEVBQ2xCLHNFQUFzRSxFQUN0RSxFQUFFLEVBQ0Ysc0NBQXNDLEVBQ3RDLG1IQUFtSCxFQUNuSCxFQUFFLEVBQ0YsaUNBQWlDLEVBQ2pDLHlDQUF5QyxFQUN6QyxxREFBcUQsRUFDckQsa0dBQWtHLEVBQ2xHLHNDQUFzQyxFQUN0QyxNQUFNLEVBQ04sTUFBTSxFQUNOLEVBQUUsRUFDRiw0RUFBNEUsRUFDNUUsMERBQTBELEVBQzFELHlDQUF5QyxFQUN6QywwREFBMEQsRUFDMUQsb0VBQW9FLEVBQ3BFLDZDQUE2QyxFQUM3QyxNQUFNLEVBQ04sTUFBTSxFQUNOLEVBQUUsRUFDRixpREFBaUQsRUFDakQsMkNBQTJDLEVBQzNDLGdDQUFnQyxFQUNoQyw2SEFBNkgsRUFDN0gsMEJBQTBCLEVBQzFCLHlIQUF5SCxFQUN6SCxNQUFNLEVBQ04sbUZBQW1GLEVBQ25GLElBQUksRUFDSixvS0FBb0ssRUFDcEssaUpBQWlKLEVBQ2pKLHVDQUF1QyxFQUN2QyxFQUFFLEVBQ0YsbURBQW1ELEVBQ25ELHlEQUF5RCxFQUN6RCxrQ0FBa0MsRUFDbEMsK0ZBQStGLEVBQy9GLHlDQUF5QyxFQUN6QyxFQUFFLEVBQ0YsZUFBZSxFQUNmLHFIQUFxSCxFQUNySCxTQUFTLEVBQ1QsRUFBRSxFQUNGLDRDQUE0QyxFQUM1QyxvQkFBb0IsRUFDcEIsaUpBQWlKLEVBQ2pKLE1BQU0sRUFDTixFQUFFLEVBQ0YsZ0NBQWdDLEVBQ2hDLFVBQVUsRUFDVixFQUFFLEVBQ0YsZ0NBQWdDLEVBQ2hDLHdDQUF3QyxFQUN4QyxzQkFBc0IsRUFDdEIsbUVBQW1FLEVBQ25FLG9DQUFvQyxFQUNwQyxXQUFXLEVBQ1gsTUFBTSxFQUNOLDBCQUEwQixFQUMxQixtRUFBbUUsRUFDbkUsTUFBTSxFQUNOLFdBQVcsRUFDWCxNQUFNLEVBQ04sRUFBRSxFQUNGLHlEQUF5RCxFQUN6RCxvR0FBb0csRUFDcEcsOENBQThDLEVBQzlDLE1BQU0sRUFDTiw2REFBNkQsRUFDN0QsVUFBVSxFQUNWLElBQUksRUFDSixFQUFFLEVBQ0YsMkdBQTJHLENBQzlHLENBQUM7UUFFRixxRUFBcUU7UUFDckUsdURBQXVEO1FBQ3ZELGlGQUFpRjtRQUNqRixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxVQUFVLEVBQUU7WUFDakcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO1lBQ2IsWUFBWSxFQUFFLGVBQWU7WUFDN0IsWUFBWTtZQUNaLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYTtZQUNqQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDdkIsUUFBUSxFQUFFLHVFQUF1RTtZQUNqRixVQUFVLEVBQUUsRUFBRSxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxrREFBa0Q7WUFDckcscUJBQXFCLEVBQUUsSUFBSSxFQUFFLDZCQUE2QjtZQUMxRCw0RUFBNEU7WUFDNUUsWUFBWSxFQUFFLENBQUM7b0JBQ1gsVUFBVSxFQUFFLFdBQVcsRUFBRSxxQkFBcUI7b0JBQzlDLE1BQU0sRUFBRSxHQUFHLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUU7d0JBQ2xELFVBQVUsRUFBRSxHQUFHLENBQUMsbUJBQW1CLENBQUMsR0FBRzt3QkFDdkMsbUJBQW1CLEVBQUUsSUFBSTtxQkFDNUIsQ0FBQztpQkFDTCxDQUFDO1NBQ0wsQ0FBQyxDQUFDO1FBRUgsc0NBQXNDO1FBQ3RDLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLGtCQUFrQixDQUFDO1FBRXZGLDREQUE0RDtRQUM1RCxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUUzRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBRTNDLGdCQUFnQjtRQUNoQixJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFO1lBQ3hDLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVTtZQUN0QixVQUFVLEVBQUUsd0JBQXdCO1NBQ3ZDLENBQUMsQ0FBQztRQUVILElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsMEJBQTBCLEVBQUU7WUFDaEQsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCO1lBQ3RDLFVBQVUsRUFBRSwrQkFBK0I7U0FDOUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSx5QkFBeUIsRUFBRTtZQUMvQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsSUFBSSxLQUFLO1lBQzlDLFVBQVUsRUFBRSw4QkFBOEI7U0FDN0MsQ0FBQyxDQUFDO1FBRUgsbUNBQW1DO1FBQ25DLEdBQUcsQ0FBQyxlQUFlLENBQUMsdUJBQXVCLENBQ3ZDLElBQUksRUFDSjtZQUNJO2dCQUNJLEVBQUUsRUFBRSxtQkFBbUI7Z0JBQ3ZCLE1BQU0sRUFBRSx3REFBd0Q7YUFDbkU7WUFDRDtnQkFDSSxFQUFFLEVBQUUsbUJBQW1CO2dCQUN2QixNQUFNLEVBQUUsa0VBQWtFO2FBQzdFO1lBQ0Q7Z0JBQ0ksRUFBRSxFQUFFLG1CQUFtQjtnQkFDdkIsTUFBTSxFQUFFLHVFQUF1RTthQUNsRjtZQUNEO2dCQUNJLEVBQUUsRUFBRSxtQkFBbUI7Z0JBQ3ZCLE1BQU0sRUFBRSwwRUFBMEU7YUFDckY7U0FDSixFQUNELElBQUksQ0FDUCxDQUFDO0lBQ04sQ0FBQztDQUNKO0FBdFdELDBEQXNXQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNkayBmcm9tIFwiYXdzLWNkay1saWJcIjtcbmltcG9ydCAqIGFzIGNka0NvbnN0cnVjdHMgZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCAqIGFzIGVjMiBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWVjMlwiO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtaWFtXCI7XG5pbXBvcnQgKiBhcyBuYWcgZnJvbSBcImNkay1uYWdcIjtcbmltcG9ydCAqIGFzIGNvbmZpZ1R5cGVzIGZyb20gXCIuL2NvbmZpZy9ub2RlLWNvbmZpZy5pbnRlcmZhY2VcIjtcblxuZXhwb3J0IGludGVyZmFjZSBOZWFySW5mcmFzdHJ1Y3R1cmVTdGFja1Byb3BzIGV4dGVuZHMgY2RrLlN0YWNrUHJvcHMge1xuICAgIGluc3RhbmNlVHlwZTogc3RyaW5nO1xuICAgIGluc3RhbmNlQ3B1VHlwZTogXCJ4ODZfNjRcIiB8IFwiYXJtNjRcIjtcbiAgICBuZWFyTmV0d29yazogY29uZmlnVHlwZXMuTmVhck5ldHdvcms7XG4gICAgbmVhclZlcnNpb246IHN0cmluZztcbiAgICBkYXRhVm9sdW1lOiBjb25maWdUeXBlcy5OZWFyRGF0YVZvbHVtZUNvbmZpZztcbiAgICBsaW1pdE91dFRyYWZmaWNNYnBzOiBudW1iZXI7XG4gICAgdnBjPzogZWMyLklWcGM7XG4gICAgc2VjdXJpdHlHcm91cD86IGVjMi5JU2VjdXJpdHlHcm91cDtcbiAgICBpbnN0YW5jZVJvbGU/OiBpYW0uSVJvbGU7XG59XG5cbmV4cG9ydCBjbGFzcyBOZWFySW5mcmFzdHJ1Y3R1cmVTdGFjayBleHRlbmRzIGNkay5TdGFjayB7XG4gICAgcHVibGljIHJlYWRvbmx5IGluc3RhbmNlSWQ6IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgaW5zdGFuY2U6IGVjMi5JbnN0YW5jZTtcbiAgICBwdWJsaWMgcmVhZG9ubHkgaW5zdGFuY2VSb2xlOiBpYW0uSVJvbGU7XG4gICAgcHVibGljIHJlYWRvbmx5IHZwYzogZWMyLklWcGM7XG4gICAgcHVibGljIHJlYWRvbmx5IHNlY3VyaXR5R3JvdXA6IGVjMi5JU2VjdXJpdHlHcm91cDtcblxuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiBjZGtDb25zdHJ1Y3RzLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IE5lYXJJbmZyYXN0cnVjdHVyZVN0YWNrUHJvcHMpIHtcbiAgICAgICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICAgICAgY29uc3QgUkVHSU9OID0gY2RrLlN0YWNrLm9mKHRoaXMpLnJlZ2lvbjtcbiAgICAgICAgY29uc3QgU1RBQ0tfTkFNRSA9IGNkay5TdGFjay5vZih0aGlzKS5zdGFja05hbWU7XG4gICAgICAgIGNvbnN0IFNUQUNLX0lEID0gY2RrLlN0YWNrLm9mKHRoaXMpLnN0YWNrSWQ7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW5zdGFuY2VUeXBlLFxuICAgICAgICAgICAgaW5zdGFuY2VDcHVUeXBlLFxuICAgICAgICAgICAgbmVhck5ldHdvcmssXG4gICAgICAgICAgICBuZWFyVmVyc2lvbixcbiAgICAgICAgICAgIGRhdGFWb2x1bWUsXG4gICAgICAgICAgICB2cGMsXG4gICAgICAgICAgICBzZWN1cml0eUdyb3VwLFxuICAgICAgICAgICAgaW5zdGFuY2VSb2xlLFxuICAgICAgICB9ID0gcHJvcHM7XG5cbiAgICAgICAgLy8gVXNlIHByb3ZpZGVkIFZQQy9zZWN1cml0eSBncm91cC9yb2xlIG9yIGltcG9ydCBmcm9tIGNvbW1vbiBzdGFja1xuICAgICAgICBpZiAodnBjICYmIHNlY3VyaXR5R3JvdXAgJiYgaW5zdGFuY2VSb2xlKSB7XG4gICAgICAgICAgICB0aGlzLnZwYyA9IHZwYztcbiAgICAgICAgICAgIHRoaXMuc2VjdXJpdHlHcm91cCA9IHNlY3VyaXR5R3JvdXA7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlUm9sZSA9IGluc3RhbmNlUm9sZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGltcG9ydHMgKGZvciBjcm9zcy1zdGFjayByZWZlcmVuY2VzIHdoZW4gc3RhY2tzIGFyZSBpbiBkaWZmZXJlbnQgYXBwcylcbiAgICAgICAgICAgIGNvbnN0IHZwY0lkID0gY2RrLkZuLmltcG9ydFZhbHVlKFwiTmVhckxvY2FsbmV0VnBjSWRcIik7XG4gICAgICAgICAgICBjb25zdCBzZWN1cml0eUdyb3VwSWQgPSBjZGsuRm4uaW1wb3J0VmFsdWUoXCJOZWFyTG9jYWxuZXRTZWN1cml0eUdyb3VwSWRcIik7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZEluc3RhbmNlUm9sZUFybiA9IGNkay5Gbi5pbXBvcnRWYWx1ZShcIk5lYXJMb2NhbG5ldEluc3RhbmNlUm9sZUFyblwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTm90ZTogVnBjLmZyb21Mb29rdXAgcmVxdWlyZXMgZW52aXJvbm1lbnQgY29udGV4dCBhbmQgd29uJ3Qgd29yayB3aXRoIGltcG9ydGVkIHZhbHVlc1xuICAgICAgICAgICAgLy8gVGhpcyBmYWxsYmFjayBpcyBmb3IgcmVmZXJlbmNlIGJ1dCBzaG91bGQgdXNlIGRpcmVjdCByZWZlcmVuY2VzIGluIGFwcC50c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVlBDLCBzZWN1cml0eSBncm91cCwgYW5kIGluc3RhbmNlIHJvbGUgbXVzdCBiZSBwcm92aWRlZCBkaXJlY3RseSB3aGVuIHN0YWNrcyBhcmUgaW4gdGhlIHNhbWUgYXBwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVWJ1bnR1IDI0LjA0IExUUyBpbWFnZSBmb3IgYW1kNjQgKHg4Nl82NCByZXF1aXJlZCBmb3IgTkVBUilcbiAgICAgICAgbGV0IHVidW50dVN0YWJsZUltYWdlU3NtTmFtZSA9IFwiL2F3cy9zZXJ2aWNlL2Nhbm9uaWNhbC91YnVudHUvc2VydmVyLzI0LjA0L3N0YWJsZS9jdXJyZW50L2FtZDY0L2h2bS9lYnMtZ3AzL2FtaS1pZFwiO1xuICAgICAgICBpZiAoaW5zdGFuY2VDcHVUeXBlID09PSBcImFybTY0XCIpIHtcbiAgICAgICAgICAgIHVidW50dVN0YWJsZUltYWdlU3NtTmFtZSA9IFwiL2F3cy9zZXJ2aWNlL2Nhbm9uaWNhbC91YnVudHUvc2VydmVyLzI0LjA0L3N0YWJsZS9jdXJyZW50L2FybTY0L2h2bS9lYnMtZ3AzL2FtaS1pZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hY2hpbmVJbWFnZSA9IGVjMi5NYWNoaW5lSW1hZ2UuZnJvbVNzbVBhcmFtZXRlcih1YnVudHVTdGFibGVJbWFnZVNzbU5hbWUpO1xuXG4gICAgICAgIC8vIFBhcnNlIGluc3RhbmNlIHR5cGUgLSBDREsgZXhwZWN0cyBJbnN0YW5jZUNsYXNzIGVudW0gYW5kIEluc3RhbmNlU2l6ZSBlbnVtXG4gICAgICAgIC8vIFwidDMubGFyZ2VcIiAtPiBJbnN0YW5jZUNsYXNzLlQzLCBJbnN0YW5jZVNpemUuTEFSR0VcbiAgICAgICAgY29uc3QgW2luc3RhbmNlQ2xhc3NTdHIsIGluc3RhbmNlU2l6ZVN0cl0gPSBpbnN0YW5jZVR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIC8vIENvbnZlcnQgXCJ0M1wiIC0+IFwiVDNcIiBmb3IgSW5zdGFuY2VDbGFzcyBlbnVtXG4gICAgICAgIGNvbnN0IGluc3RhbmNlQ2xhc3MgPSAoaW5zdGFuY2VDbGFzc1N0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGluc3RhbmNlQ2xhc3NTdHIuc2xpY2UoMSkpLnRvVXBwZXJDYXNlKCkgYXMgZWMyLkluc3RhbmNlQ2xhc3M7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlU2l6ZSA9IGluc3RhbmNlU2l6ZVN0ci50b1VwcGVyQ2FzZSgpIGFzIGVjMi5JbnN0YW5jZVNpemU7XG4gICAgICAgIGNvbnN0IGVjMkluc3RhbmNlVHlwZSA9IG5ldyBlYzIuSW5zdGFuY2VUeXBlKGAke2luc3RhbmNlQ2xhc3NTdHJ9LiR7aW5zdGFuY2VTaXplU3RyfWApO1xuXG4gICAgICAgIC8vIFVzZXJEYXRhIHNjcmlwdCBmb2xsb3dpbmcgdGhlIHdvcmtpbmcgaW1wbGVtZW50YXRpb24gZnJvbSBjaGFpbi1tb2JpbC9jZGtcbiAgICAgICAgLy8gVGhpcyBjb21waWxlcyBhbmQgcnVucyBuZWFyZCBvbiBVYnVudHUgcGVyIE5FQVIncyByZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgLy8gTW9kaWZpZWQgdG8gYWRkIGxvY2FsbmV0IHJvb3QgYWNjb3VudCB0byBnZW5lc2lzIGZvciAubG9jYWxuZXQgbmFtaW5nIHBhcml0eVxuICAgICAgICAvLyBGb3JjZSByZXBsYWNlbWVudDogMjAyNS0xMi0zMFQwNTozNTowMFpcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBlYzIuVXNlckRhdGEuZm9yTGludXgoKTtcbiAgICAgICAgdXNlckRhdGEuYWRkQ29tbWFuZHMoXG4gICAgICAgICAgICAnIyEvYmluL2Jhc2gnLFxuICAgICAgICAgICAgJ3NldCAtZScsXG4gICAgICAgICAgICAnZXhlYyA+ID4odGVlIC92YXIvbG9nL25lYXItc2V0dXAubG9nKSAyPiYxJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgRm9yY2UgcmVwbGFjZW1lbnQgdGltZXN0YW1wOiAyMDI1LTEyLTMwVDA1OjM1OjAwWicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFVwZGF0ZSBzeXN0ZW0nLFxuICAgICAgICAgICAgJ2FwdCB1cGRhdGUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBJbnN0YWxsIGRlcGVuZGVuY2llcyBmb3IgTkVBUiBjb21waWxhdGlvbiAoVWJ1bnR1IHBhY2thZ2VzKScsXG4gICAgICAgICAgICAvLyBOT1RFOiBVYnVudHUgMjQuMDQgbm8gbG9uZ2VyIHByb3ZpZGVzIGFuIGBhd3NjbGlgIGFwdCBjYW5kaWRhdGUgaW4gc29tZSBpbWFnZXMvcmVwb3MuXG4gICAgICAgICAgICAvLyBJbnN0YWxsIEFXUyBDTEkgdmlhIHBpcCBiZWxvdy5cbiAgICAgICAgICAgICdhcHQgaW5zdGFsbCAteSBnaXQgYmludXRpbHMtZGV2IGxpYmN1cmw0LW9wZW5zc2wtZGV2IHpsaWIxZy1kZXYgbGliZHctZGV2IGxpYmliZXJ0eS1kZXYgY21ha2UgZ2NjIGcrKyBweXRob24zIHB5dGhvbjMtcGlwIHByb3RvYnVmLWNvbXBpbGVyIGxpYnNzbC1kZXYgcGtnLWNvbmZpZyBjbGFuZyBsbHZtIGpxJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgSW5zdGFsbCBSdXN0IGFzIHVidW50dSB1c2VyJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcImN1cmwgLS1wcm90byA9aHR0cHMgLS10bHN2MS4yIC1zU2YgaHR0cHM6Ly9zaC5ydXN0dXAucnMgfCBzaCAtcyAtLSAteVwiJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcInNvdXJjZSB+Ly5jYXJnby9lbnYgJiYgcnVzdGMgLS12ZXJzaW9uXCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBDbG9uZSBuZWFyY29yZScsXG4gICAgICAgICAgICAnc3UgLSB1YnVudHUgLWMgXCJjZCB+ICYmIGdpdCBjbG9uZSBodHRwczovL2dpdGh1Yi5jb20vbmVhci9uZWFyY29yZS5naXRcIicsXG4gICAgICAgICAgICBgc3UgLSB1YnVudHUgLWMgXCJjZCB+L25lYXJjb3JlICYmIGdpdCBjaGVja291dCAke25lYXJWZXJzaW9ufVwiYCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgQ29tcGlsZSBuZWFyZCAodGFrZXMgfjEwLTE1IG1pbnV0ZXMpJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcImNkIH4vbmVhcmNvcmUgJiYgc291cmNlIH4vLmNhcmdvL2VudiAmJiBtYWtlIG5lYXJkXCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBJbnN0YWxsIG5lYXJ1cCAoVWJ1bnR1IDI0LjA0IHJlcXVpcmVzIC0tYnJlYWstc3lzdGVtLXBhY2thZ2VzKScsXG4gICAgICAgICAgICAnc3UgLSB1YnVudHUgLWMgXCJwaXAzIGluc3RhbGwgLS11c2VyIC0tYnJlYWstc3lzdGVtLXBhY2thZ2VzIG5lYXJ1cFwiJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgSW5zdGFsbCBBV1MgQ0xJIChyZXF1aXJlZCBmb3Igd3JpdGluZyBTU00gcGFyYW1ldGVycyBkdXJpbmcgYm9vdHN0cmFwKScsXG4gICAgICAgICAgICAncGlwMyBpbnN0YWxsIC0tYnJlYWstc3lzdGVtLXBhY2thZ2VzIGF3c2NsaScsXG4gICAgICAgICAgICAnYXdzIC0tdmVyc2lvbiB8fCB0cnVlJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgUnVuIG5lYXJ1cCBsb2NhbG5ldCB3aXRoIGNvbXBpbGVkIGJpbmFyeSAoY3JlYXRlcyBnZW5lc2lzLmpzb24pJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcImV4cG9ydCBQQVRIPSRQQVRIOn4vLmxvY2FsL2JpbiAmJiBuZWFydXAgcnVuIGxvY2FsbmV0IC0tYmluYXJ5LXBhdGggfi9uZWFyY29yZS90YXJnZXQvcmVsZWFzZVwiID4gL3Zhci9sb2cvbmVhcnVwLmxvZyAyPiYxICYnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBXYWl0IGZvciBnZW5lc2lzLmpzb24gdG8gYmUgY3JlYXRlZCBieSBuZWFydXAnLFxuICAgICAgICAgICAgJ2VjaG8gXCJXYWl0aW5nIGZvciBnZW5lc2lzLmpzb24gdG8gYmUgY3JlYXRlZC4uLlwiJyxcbiAgICAgICAgICAgICdmb3IgaSBpbiB7MS4uNjB9OyBkbycsXG4gICAgICAgICAgICAnICBpZiBbIC1mIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC9ub2RlMC9nZW5lc2lzLmpzb24gXTsgdGhlbicsXG4gICAgICAgICAgICAnICAgIGVjaG8gXCJHZW5lc2lzIGZpbGUgZm91bmRcIicsXG4gICAgICAgICAgICAnICAgIGJyZWFrJyxcbiAgICAgICAgICAgICcgIGZpJyxcbiAgICAgICAgICAgICcgIHNsZWVwIDInLFxuICAgICAgICAgICAgJ2RvbmUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBTdG9wIG5lYXJ1cCBhbmQgYWxsIG5lYXJkIHByb2Nlc3NlcyBiZWZvcmUgcGF0Y2hpbmcgZ2VuZXNpcycsXG4gICAgICAgICAgICAnZWNobyBcIlN0b3BwaW5nIG5lYXJ1cCBhbmQgbmVhcmQgcHJvY2Vzc2VzLi4uXCInLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwicGtpbGwgLWYgbmVhcnVwIHx8IHRydWVcIicsXG4gICAgICAgICAgICAnc3UgLSB1YnVudHUgLWMgXCJwa2lsbCAtZiBuZWFyZCB8fCB0cnVlXCInLFxuICAgICAgICAgICAgJ3NsZWVwIDUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBHZW5lcmF0ZSBsb2NhbG5ldCBrZXlwYWlyIHVzaW5nIG5lYXJkIGluaXQgKHdvcmtzIGluIG5lYXJkIDIuMTAuMSknLFxuICAgICAgICAgICAgJ2VjaG8gXCJHZW5lcmF0aW5nIGxvY2FsbmV0IGtleXBhaXIgdXNpbmcgbmVhcmQgaW5pdC4uLlwiJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcInJtIC1yZiB+Ly5uZWFyL2xvY2FsbmV0LWtleWdlbiAmJiBta2RpciAtcCB+Ly5uZWFyL2xvY2FsbmV0LWtleWdlblwiJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcIn4vbmVhcmNvcmUvdGFyZ2V0L3JlbGVhc2UvbmVhcmQgLS1ob21lIH4vLm5lYXIvbG9jYWxuZXQta2V5Z2VuIGluaXQgLS1hY2NvdW50LWlkIGxvY2FsbmV0IC0tY2hhaW4taWQgbG9jYWxuZXQgLS1mYXN0XCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBFeHRyYWN0IHB1YmxpYyBhbmQgc2VjcmV0IGtleXMgZnJvbSB2YWxpZGF0b3Jfa2V5Lmpzb24nLFxuICAgICAgICAgICAgJ0xPQ0FMTkVUX0tFWV9GSUxFPVwiL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0LWtleWdlbi92YWxpZGF0b3Jfa2V5Lmpzb25cIicsXG4gICAgICAgICAgICAnaWYgWyAhIC1mIFwiJExPQ0FMTkVUX0tFWV9GSUxFXCIgXTsgdGhlbicsXG4gICAgICAgICAgICAnICBlY2hvIFwiRVJST1I6IHZhbGlkYXRvcl9rZXkuanNvbiBub3QgZm91bmQgYWZ0ZXIgbmVhcmQgaW5pdFwiJyxcbiAgICAgICAgICAgICcgIGV4aXQgMScsXG4gICAgICAgICAgICAnZmknLFxuICAgICAgICAgICAgJ0xPQ0FMTkVUX1BVQkxJQ19LRVk9JChzdSAtIHVidW50dSAtYyBcImNhdCAkTE9DQUxORVRfS0VZX0ZJTEUgfCBqcSAtciBcXCcucHVibGljX2tleVxcJ1wiIDI+L2Rldi9udWxsIHx8IGVjaG8gXCJcIiknLFxuICAgICAgICAgICAgJ0xPQ0FMTkVUX1NFQ1JFVF9LRVk9JChzdSAtIHVidW50dSAtYyBcImNhdCAkTE9DQUxORVRfS0VZX0ZJTEUgfCBqcSAtciBcXCcuc2VjcmV0X2tleVxcJ1wiIDI+L2Rldi9udWxsIHx8IGVjaG8gXCJcIiknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnaWYgWyAteiBcIiRMT0NBTE5FVF9QVUJMSUNfS0VZXCIgXSB8fCBbIC16IFwiJExPQ0FMTkVUX1NFQ1JFVF9LRVlcIiBdIHx8IFsgXCIkTE9DQUxORVRfUFVCTElDX0tFWVwiID0gXCJudWxsXCIgXSB8fCBbIFwiJExPQ0FMTkVUX1NFQ1JFVF9LRVlcIiA9IFwibnVsbFwiIF07IHRoZW4nLFxuICAgICAgICAgICAgJyAgZWNobyBcIkVSUk9SOiBDb3VsZCBub3QgZXh0cmFjdCBsb2NhbG5ldCBrZXlzIGZyb20gdmFsaWRhdG9yX2tleS5qc29uXCInLFxuICAgICAgICAgICAgJyAgZXhpdCAxJyxcbiAgICAgICAgICAgICdmaScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIENyZWF0ZSBQeXRob24gc2NyaXB0IGZvciBnZW5lc2lzIHBhdGNoaW5nIHdpdGggcmVhbGxvY2F0aW9uJyxcbiAgICAgICAgICAgICdjYXQgPiAvdG1wL3BhdGNoLWdlbmVzaXMtbG9jYWxuZXQucHkgPDwgXFwnUFlFT0ZcXCcnLFxuICAgICAgICAgICAgJyMhL3Vzci9iaW4vZW52IHB5dGhvbjMnLFxuICAgICAgICAgICAgJ2ltcG9ydCBqc29uJyxcbiAgICAgICAgICAgICdpbXBvcnQgc3lzJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ2lmIGxlbihzeXMuYXJndikgIT0gNTonLFxuICAgICAgICAgICAgJyAgICBwcmludChcIlVzYWdlOiBwYXRjaC1nZW5lc2lzLWxvY2FsbmV0LnB5IDxnZW5lc2lzLmpzb24+IDxwdWJsaWNfa2V5PiA8dHJhbnNmZXJfYW1vdW50PiA8b3V0cHV0Lmpzb24+XCIpJyxcbiAgICAgICAgICAgICcgICAgc3lzLmV4aXQoMSknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnZ2VuZXNpc19wYXRoID0gc3lzLmFyZ3ZbMV0nLFxuICAgICAgICAgICAgJ3B1YmxpY19rZXkgPSBzeXMuYXJndlsyXScsXG4gICAgICAgICAgICAndHJhbnNmZXJfYW1vdW50ID0gc3lzLmFyZ3ZbM10nLFxuICAgICAgICAgICAgJ291dHB1dF9wYXRoID0gc3lzLmFyZ3ZbNF0nLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnd2l0aCBvcGVuKGdlbmVzaXNfcGF0aCwgXFwnclxcJykgYXMgZjonLFxuICAgICAgICAgICAgJyAgICBnZW5lc2lzID0ganNvbi5sb2FkKGYpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgRmluZCBub2RlMCBBY2NvdW50IHJlY29yZCBhbmQgc3VidHJhY3QgdHJhbnNmZXJfYW1vdW50JyxcbiAgICAgICAgICAgICdub2RlMF9mb3VuZCA9IEZhbHNlJyxcbiAgICAgICAgICAgICdmb3IgcmVjb3JkIGluIGdlbmVzaXMuZ2V0KFxcJ3JlY29yZHNcXCcsIFtdKTonLFxuICAgICAgICAgICAgJyAgICBpZiBcXCdBY2NvdW50XFwnIGluIHJlY29yZDonLFxuICAgICAgICAgICAgJyAgICAgICAgYWNjb3VudCA9IHJlY29yZFtcXCdBY2NvdW50XFwnXScsXG4gICAgICAgICAgICAnICAgICAgICBpZiBhY2NvdW50LmdldChcXCdhY2NvdW50X2lkXFwnKSA9PSBcXCdub2RlMFxcJzonLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIG5vZGUwX2ZvdW5kID0gVHJ1ZScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgY3VycmVudF9hbW91bnQgPSBpbnQoYWNjb3VudFtcXCdhY2NvdW50XFwnXVtcXCdhbW91bnRcXCddKScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgbmV3X2Ftb3VudCA9IGN1cnJlbnRfYW1vdW50IC0gaW50KHRyYW5zZmVyX2Ftb3VudCknLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGlmIG5ld19hbW91bnQgPCAwOicsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgIHByaW50KGZcIkVSUk9SOiBub2RlMCBiYWxhbmNlICh7Y3VycmVudF9hbW91bnR9KSBpbnN1ZmZpY2llbnQgZm9yIHRyYW5zZmVyICh7dHJhbnNmZXJfYW1vdW50fSlcIiknLFxuICAgICAgICAgICAgJyAgICAgICAgICAgICAgICBzeXMuZXhpdCgxKScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgYWNjb3VudFtcXCdhY2NvdW50XFwnXVtcXCdhbW91bnRcXCddID0gc3RyKG5ld19hbW91bnQpJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBwcmludChmXCJSZWFsbG9jYXRlZCB7dHJhbnNmZXJfYW1vdW50fSB5b2N0b05FQVIgZnJvbSBub2RlMCAobmV3IGJhbGFuY2U6IHtuZXdfYW1vdW50fSlcIiknLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIGJyZWFrJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ2lmIG5vdCBub2RlMF9mb3VuZDonLFxuICAgICAgICAgICAgJyAgICBwcmludChcIkVSUk9SOiBub2RlMCBBY2NvdW50IHJlY29yZCBub3QgZm91bmQgaW4gZ2VuZXNpc1wiKScsXG4gICAgICAgICAgICAnICAgIHN5cy5leGl0KDEpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgQWRkIGxvY2FsbmV0IEFjY291bnQgcmVjb3JkJyxcbiAgICAgICAgICAgICdsb2NhbG5ldF9hY2NvdW50X3JlY29yZCA9IHsnLFxuICAgICAgICAgICAgJyAgICBcIkFjY291bnRcIjogeycsXG4gICAgICAgICAgICAnICAgICAgICBcImFjY291bnRfaWRcIjogXCJsb2NhbG5ldFwiLCcsXG4gICAgICAgICAgICAnICAgICAgICBcImFjY291bnRcIjogeycsXG4gICAgICAgICAgICAnICAgICAgICAgICAgXCJhbW91bnRcIjogdHJhbnNmZXJfYW1vdW50LCcsXG4gICAgICAgICAgICAnICAgICAgICAgICAgXCJsb2NrZWRcIjogXCIwXCIsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcImNvZGVfaGFzaFwiOiBcIjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcInN0b3JhZ2VfdXNhZ2VcIjogMTgyLCcsXG4gICAgICAgICAgICAnICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiVjFcIicsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnZ2VuZXNpc1tcXCdyZWNvcmRzXFwnXS5hcHBlbmQobG9jYWxuZXRfYWNjb3VudF9yZWNvcmQpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgQWRkIGxvY2FsbmV0IEFjY2Vzc0tleSByZWNvcmQnLFxuICAgICAgICAgICAgJ2xvY2FsbmV0X2FjY2Vzc19rZXlfcmVjb3JkID0geycsXG4gICAgICAgICAgICAnICAgIFwiQWNjZXNzS2V5XCI6IHsnLFxuICAgICAgICAgICAgJyAgICAgICAgXCJhY2NvdW50X2lkXCI6IFwibG9jYWxuZXRcIiwnLFxuICAgICAgICAgICAgJyAgICAgICAgXCJwdWJsaWNfa2V5XCI6IHB1YmxpY19rZXksJyxcbiAgICAgICAgICAgICcgICAgICAgIFwiYWNjZXNzX2tleVwiOiB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcIm5vbmNlXCI6IDAsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcInBlcm1pc3Npb25cIjogXCJGdWxsQWNjZXNzXCInLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJ2dlbmVzaXNbXFwncmVjb3Jkc1xcJ10uYXBwZW5kKGxvY2FsbmV0X2FjY2Vzc19rZXlfcmVjb3JkKScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICd3aXRoIG9wZW4ob3V0cHV0X3BhdGgsIFxcJ3dcXCcpIGFzIGY6JyxcbiAgICAgICAgICAgICcgICAganNvbi5kdW1wKGdlbmVzaXMsIGYsIGluZGVudD0yKScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdwcmludChmXCJHZW5lc2lzIHBhdGNoZWQgc3VjY2Vzc2Z1bGx5OiB7b3V0cHV0X3BhdGh9XCIpJyxcbiAgICAgICAgICAgICdQWUVPRicsXG4gICAgICAgICAgICAnY2htb2QgK3ggL3RtcC9wYXRjaC1nZW5lc2lzLWxvY2FsbmV0LnB5JyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgUGF0Y2ggZ2VuZXNpcy5qc29uIHdpdGggcmVhbGxvY2F0aW9uIGZyb20gbm9kZTAnLFxuICAgICAgICAgICAgJ2VjaG8gXCJQYXRjaGluZyBnZW5lc2lzLmpzb24gd2l0aCBsb2NhbG5ldCBhY2NvdW50IChyZWFsbG9jYXRpbmcgZnJvbSBub2RlMCkuLi5cIicsXG4gICAgICAgICAgICAnR0VORVNJU19QQVRIPVwiL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0L25vZGUwL2dlbmVzaXMuanNvblwiJyxcbiAgICAgICAgICAgICdBTU9VTlQ9XCIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiAgIyAxMDAsMDAwIE5FQVInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBCYWNrdXAgZ2VuZXNpcycsXG4gICAgICAgICAgICAnc3UgLSB1YnVudHUgLWMgXCJjcCAkR0VORVNJU19QQVRIICR7R0VORVNJU19QQVRIfS5iYWNrdXAuJChkYXRlICslcylcIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFJ1biBQeXRob24gc2NyaXB0IHRvIHBhdGNoIGdlbmVzaXMnLFxuICAgICAgICAgICAgJ3B5dGhvbjMgL3RtcC9wYXRjaC1nZW5lc2lzLWxvY2FsbmV0LnB5IFwiJEdFTkVTSVNfUEFUSFwiIFwiJExPQ0FMTkVUX1BVQkxJQ19LRVlcIiBcIiRBTU9VTlRcIiAvdG1wL2dlbmVzaXNfcGF0Y2hlZC5qc29uJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgUmVwbGFjZSBnZW5lc2lzIGZvciBhbGwgbm9kZXMnLFxuICAgICAgICAgICAgJ2ZvciBub2RlIGluIG5vZGUwIG5vZGUxIG5vZGUyIG5vZGUzOyBkbycsXG4gICAgICAgICAgICAnICBpZiBbIC1kIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC8kbm9kZSBdOyB0aGVuJyxcbiAgICAgICAgICAgICcgICAgc3UgLSB1YnVudHUgLWMgXCJjcCAvdG1wL2dlbmVzaXNfcGF0Y2hlZC5qc29uIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC8kbm9kZS9nZW5lc2lzLmpzb25cIicsXG4gICAgICAgICAgICAnICAgIGVjaG8gXCJVcGRhdGVkIGdlbmVzaXMgZm9yICRub2RlXCInLFxuICAgICAgICAgICAgJyAgZmknLFxuICAgICAgICAgICAgJ2RvbmUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBSZW1vdmUgbm9kZSBkYXRhIGRpcmVjdG9yaWVzIHNvIG5vZGVzIHN0YXJ0IGNsZWFubHkgd2l0aCBwYXRjaGVkIGdlbmVzaXMnLFxuICAgICAgICAgICAgJ2VjaG8gXCJSZW1vdmluZyBub2RlIGRhdGEgZGlyZWN0b3JpZXMgZm9yIGNsZWFuIHN0YXJ0Li4uXCInLFxuICAgICAgICAgICAgJ2ZvciBub2RlIGluIG5vZGUwIG5vZGUxIG5vZGUyIG5vZGUzOyBkbycsXG4gICAgICAgICAgICAnICBpZiBbIC1kIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC8kbm9kZS9kYXRhIF07IHRoZW4nLFxuICAgICAgICAgICAgJyAgICBzdSAtIHVidW50dSAtYyBcInJtIC1yZiAvaG9tZS91YnVudHUvLm5lYXIvbG9jYWxuZXQvJG5vZGUvZGF0YVwiJyxcbiAgICAgICAgICAgICcgICAgZWNobyBcIlJlbW92ZWQgZGF0YSBkaXJlY3RvcnkgZm9yICRub2RlXCInLFxuICAgICAgICAgICAgJyAgZmknLFxuICAgICAgICAgICAgJ2RvbmUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBTdG9yZSBsb2NhbG5ldCBrZXlwYWlyIGluIFNTTSBQYXJhbWV0ZXIgU3RvcmUnLFxuICAgICAgICAgICAgJ2VjaG8gXCJTdG9yaW5nIGxvY2FsbmV0IGtleXBhaXIgaW4gU1NNLi4uXCInLFxuICAgICAgICAgICAgJyMgSU1EU3YyLXNhZmUgcmVnaW9uIGRpc2NvdmVyeScsXG4gICAgICAgICAgICAnVE9LRU49JChjdXJsIC1zUyAtWCBQVVQgXCJodHRwOi8vMTY5LjI1NC4xNjkuMjU0L2xhdGVzdC9hcGkvdG9rZW5cIiAtSCBcIlgtYXdzLWVjMi1tZXRhZGF0YS10b2tlbi10dGwtc2Vjb25kczogMjE2MDBcIiB8fCB0cnVlKScsXG4gICAgICAgICAgICAnaWYgWyAtbiBcIiRUT0tFTlwiIF07IHRoZW4nLFxuICAgICAgICAgICAgJyAgQVdTX1JFR0lPTj0kKGN1cmwgLXNTIC1IIFwiWC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuOiAkVE9LRU5cIiBodHRwOi8vMTY5LjI1NC4xNjkuMjU0L2xhdGVzdC9tZXRhLWRhdGEvcGxhY2VtZW50L3JlZ2lvbiknLFxuICAgICAgICAgICAgJ2Vsc2UnLFxuICAgICAgICAgICAgJyAgQVdTX1JFR0lPTj0kKGN1cmwgLXNTIGh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvbGF0ZXN0L21ldGEtZGF0YS9wbGFjZW1lbnQvcmVnaW9uKScsXG4gICAgICAgICAgICAnZmknLFxuICAgICAgICAgICAgJ2F3cyBzc20gcHV0LXBhcmFtZXRlciAtLW5hbWUgXCIvbmVhci1sb2NhbG5ldC9sb2NhbG5ldC1hY2NvdW50LWtleVwiIC0tdmFsdWUgXCIkTE9DQUxORVRfU0VDUkVUX0tFWVwiIC0tdHlwZSBcIlNlY3VyZVN0cmluZ1wiIC0tb3ZlcndyaXRlIC0tcmVnaW9uIFwiJEFXU19SRUdJT05cIiB8fCB0cnVlJyxcbiAgICAgICAgICAgICdhd3Mgc3NtIHB1dC1wYXJhbWV0ZXIgLS1uYW1lIFwiL25lYXItbG9jYWxuZXQvbG9jYWxuZXQtYWNjb3VudC1pZFwiIC0tdmFsdWUgXCJsb2NhbG5ldFwiIC0tdHlwZSBcIlN0cmluZ1wiIC0tb3ZlcndyaXRlIC0tcmVnaW9uIFwiJEFXU19SRUdJT05cIiB8fCB0cnVlJyxcbiAgICAgICAgICAgICdlY2hvIFwiTG9jYWxuZXQga2V5cGFpciBzdG9yZWQgaW4gU1NNXCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBTdGFydCBuZWFyZCBwcm9jZXNzZXMgZGlyZWN0bHkgKG5vdCB2aWEgbmVhcnVwKScsXG4gICAgICAgICAgICAnZWNobyBcIlN0YXJ0aW5nIG5lYXJkIHByb2Nlc3NlcyB3aXRoIHBhdGNoZWQgZ2VuZXNpcy4uLlwiJyxcbiAgICAgICAgICAgICcjIEdldCBub2RlMCBib290IG5vZGUgcHVibGljIGtleScsXG4gICAgICAgICAgICAnQk9PVF9QVUI9JChzdSAtIHVidW50dSAtYyBcImNhdCB+Ly5uZWFyL2xvY2FsbmV0L25vZGUwL25vZGVfa2V5Lmpzb24gfCBqcSAtciBcXCcucHVibGljX2tleVxcJ1wiKScsXG4gICAgICAgICAgICAnQk9PVF9OT0RFPVwiJHtCT09UX1BVQn1AMTI3LjAuMC4xOjI0NTY3XCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBTdGFydCBub2RlMCcsXG4gICAgICAgICAgICAnc3UgLSB1YnVudHUgLWMgXCJub2h1cCB+L25lYXJjb3JlL3RhcmdldC9yZWxlYXNlL25lYXJkIC0taG9tZSB+Ly5uZWFyL2xvY2FsbmV0L25vZGUwIHJ1biA+IH4vbmVhcmQtbm9kZTAubG9nIDI+JjEgJlwiJyxcbiAgICAgICAgICAgICdzbGVlcCAyJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgU3RhcnQgbm9kZTEsIG5vZGUyLCBub2RlMyB3aXRoIGJvb3Qgbm9kZScsXG4gICAgICAgICAgICAnZm9yIGkgaW4gMSAyIDM7IGRvJyxcbiAgICAgICAgICAgICcgIHN1IC0gdWJ1bnR1IC1jIFwibm9odXAgfi9uZWFyY29yZS90YXJnZXQvcmVsZWFzZS9uZWFyZCAtLWhvbWUgfi8ubmVhci9sb2NhbG5ldC9ub2RlJGkgcnVuIC0tYm9vdC1ub2RlcyAkQk9PVF9OT0RFID4gfi9uZWFyZC1ub2RlJGkubG9nIDI+JjEgJlwiJyxcbiAgICAgICAgICAgICdkb25lJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgV2FpdCBmb3Igbm9kZXMgdG8gaW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAnc2xlZXAgMTAnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBWYWxpZGF0aW9uOiBDaGVjayBSUEMgc3RhdHVzJyxcbiAgICAgICAgICAgICdlY2hvIFwiVmFsaWRhdGluZyBORUFSIG5vZGUgc3RhcnR1cC4uLlwiJyxcbiAgICAgICAgICAgICdmb3IgaSBpbiB7MS4uMzB9OyBkbycsXG4gICAgICAgICAgICAnICBpZiBjdXJsIC1zUyBodHRwOi8vMTI3LjAuMC4xOjMwMzAvc3RhdHVzID4gL2Rldi9udWxsIDI+JjE7IHRoZW4nLFxuICAgICAgICAgICAgJyAgICBlY2hvIFwiUlBDIGVuZHBvaW50IHJlc3BvbmRpbmdcIicsXG4gICAgICAgICAgICAnICAgIGJyZWFrJyxcbiAgICAgICAgICAgICcgIGZpJyxcbiAgICAgICAgICAgICcgIGlmIFsgJGkgLWVxIDMwIF07IHRoZW4nLFxuICAgICAgICAgICAgJyAgICBlY2hvIFwiV0FSTklORzogUlBDIGVuZHBvaW50IG5vdCByZXNwb25kaW5nIGFmdGVyIDMwIGF0dGVtcHRzXCInLFxuICAgICAgICAgICAgJyAgZmknLFxuICAgICAgICAgICAgJyAgc2xlZXAgMicsXG4gICAgICAgICAgICAnZG9uZScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFZhbGlkYXRpb246IFZlcmlmeSBsb2NhbG5ldCBhY2NvdW50IGV4aXN0cyBpbiBnZW5lc2lzJyxcbiAgICAgICAgICAgICdpZiBncmVwIC1xIFwiXFxcXFwiYWNjb3VudF9pZFxcXFxcIjogXFxcXFwibG9jYWxuZXRcXFxcXCJcIiAvaG9tZS91YnVudHUvLm5lYXIvbG9jYWxuZXQvbm9kZTAvZ2VuZXNpcy5qc29uOyB0aGVuJyxcbiAgICAgICAgICAgICcgIGVjaG8gXCLinIUgR2VuZXNpcyBjb250YWlucyBsb2NhbG5ldCBhY2NvdW50XCInLFxuICAgICAgICAgICAgJ2Vsc2UnLFxuICAgICAgICAgICAgJyAgZWNobyBcIuKdjCBFUlJPUjogR2VuZXNpcyBkb2VzIG5vdCBjb250YWluIGxvY2FsbmV0IGFjY291bnRcIicsXG4gICAgICAgICAgICAnICBleGl0IDEnLFxuICAgICAgICAgICAgJ2ZpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ2VjaG8gXCJORUFSIGxvY2FsbmV0IGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIHdpdGggbG9jYWxuZXQgcm9vdCBhY2NvdW50XCIgPiAvdmFyL2xvZy9uZWFyLWluaXQtY29tcGxldGUubG9nJ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIENyZWF0ZSBFQzIgaW5zdGFuY2UgKGZvbGxvd2luZyB3b3JraW5nIGNoYWluLW1vYmlsIGltcGxlbWVudGF0aW9uKVxuICAgICAgICAvLyBDaGFuZ2VkIElEIHRvIGZvcmNlIHJlcGxhY2VtZW50IHdoZW4gdmVyc2lvbiB1cGRhdGVzXG4gICAgICAgIC8vIEFkZGVkIHRpbWVzdGFtcCBzdWZmaXggdG8gZm9yY2UgbmV3IGluc3RhbmNlIGNyZWF0aW9uIGZvciBnZW5lc2lzIG1vZGlmaWNhdGlvblxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IGVjMi5JbnN0YW5jZSh0aGlzLCBgTmVhckxvY2FsbmV0Tm9kZVYke25lYXJWZXJzaW9uLnJlcGxhY2UoL1xcLi9nLCBcIlwiKX1Mb2NhbG5ldGAsIHtcbiAgICAgICAgICAgIHZwYzogdGhpcy52cGMsXG4gICAgICAgICAgICBpbnN0YW5jZVR5cGU6IGVjMkluc3RhbmNlVHlwZSxcbiAgICAgICAgICAgIG1hY2hpbmVJbWFnZSxcbiAgICAgICAgICAgIHNlY3VyaXR5R3JvdXA6IHRoaXMuc2VjdXJpdHlHcm91cCxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMuaW5zdGFuY2VSb2xlLFxuICAgICAgICAgICAgdXNlckRhdGEsIC8vIFNldCBVc2VyRGF0YSBkaXJlY3RseSAoZm9sbG93aW5nIHdvcmtpbmcgY2hhaW4tbW9iaWwgaW1wbGVtZW50YXRpb24pXG4gICAgICAgICAgICB2cGNTdWJuZXRzOiB7IHN1Ym5ldFR5cGU6IGVjMi5TdWJuZXRUeXBlLlBVQkxJQyB9LCAvLyBGb3Igb3V0Ym91bmQgaW50ZXJuZXQgKGRvd25sb2FkIFJ1c3QsIG5lYXJjb3JlKVxuICAgICAgICAgICAgc3NtU2Vzc2lvblBlcm1pc3Npb25zOiB0cnVlLCAvLyBFbmFibGUgU1NNIFNlc3Npb24gTWFuYWdlclxuICAgICAgICAgICAgLy8gSW5jcmVhc2Ugcm9vdCB2b2x1bWUgc2l6ZSBmb3IgUnVzdCBjb21waWxhdGlvbiAoZGVmYXVsdCA4R0IgaXMgdG9vIHNtYWxsKVxuICAgICAgICAgICAgYmxvY2tEZXZpY2VzOiBbe1xuICAgICAgICAgICAgICAgIGRldmljZU5hbWU6IFwiL2Rldi9zZGExXCIsIC8vIFVidW50dSByb290IGRldmljZVxuICAgICAgICAgICAgICAgIHZvbHVtZTogZWMyLkJsb2NrRGV2aWNlVm9sdW1lLmVicyhkYXRhVm9sdW1lLnNpemVHaUIsIHtcbiAgICAgICAgICAgICAgICAgICAgdm9sdW1lVHlwZTogZWMyLkVic0RldmljZVZvbHVtZVR5cGUuR1AzLFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVPblRlcm1pbmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBsb2dpY2FsIElEIGZvciBjZm4tc2lnbmFsXG4gICAgICAgIGNvbnN0IG5vZGVDRkxvZ2ljYWxJZCA9IHRoaXMuaW5zdGFuY2Uubm9kZS5kZWZhdWx0Q2hpbGQ/Lm5vZGUuaWQgfHwgXCJOZWFyTG9jYWxuZXROb2RlXCI7XG5cbiAgICAgICAgLy8gQWRkIHZlcnNpb24gdGFnIHRvIGZvcmNlIHJlcGxhY2VtZW50IHdoZW4gdmVyc2lvbiBjaGFuZ2VzXG4gICAgICAgIGNkay5UYWdzLm9mKHRoaXMuaW5zdGFuY2UpLmFkZChcIk5lYXJWZXJzaW9uXCIsIG5lYXJWZXJzaW9uKTtcblxuICAgICAgICB0aGlzLmluc3RhbmNlSWQgPSB0aGlzLmluc3RhbmNlLmluc3RhbmNlSWQ7XG5cbiAgICAgICAgLy8gU3RhY2sgb3V0cHV0c1xuICAgICAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCBcIm5lYXItaW5zdGFuY2UtaWRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgIGV4cG9ydE5hbWU6IFwiTmVhckxvY2FsbmV0SW5zdGFuY2VJZFwiLFxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCBcIm5lYXItaW5zdGFuY2UtcHJpdmF0ZS1pcFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5pbnN0YW5jZS5pbnN0YW5jZVByaXZhdGVJcCxcbiAgICAgICAgICAgIGV4cG9ydE5hbWU6IFwiTmVhckxvY2FsbmV0SW5zdGFuY2VQcml2YXRlSXBcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IGNkay5DZm5PdXRwdXQodGhpcywgXCJuZWFyLWluc3RhbmNlLXB1YmxpYy1pcFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5pbnN0YW5jZS5pbnN0YW5jZVB1YmxpY0lwIHx8IFwiTi9BXCIsXG4gICAgICAgICAgICBleHBvcnROYW1lOiBcIk5lYXJMb2NhbG5ldEluc3RhbmNlUHVibGljSXBcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkaW5nIHN1cHByZXNzaW9ucyB0byB0aGUgc3RhY2tcbiAgICAgICAgbmFnLk5hZ1N1cHByZXNzaW9ucy5hZGRSZXNvdXJjZVN1cHByZXNzaW9ucyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogXCJBd3NTb2x1dGlvbnMtRUMyM1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiU1NIIGFjY2VzcyBuZWVkZWQgZm9yIGRlYnVnZ2luZywgUlBDIHJlc3RyaWN0ZWQgdG8gVlBDXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcIkF3c1NvbHV0aW9ucy1FQzI2XCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJFQlMgZW5jcnlwdGlvbiBub3QgcmVxdWlyZWQgZm9yIGxvY2FsbmV0IGRldmVsb3BtZW50IGVudmlyb25tZW50XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcIkF3c1NvbHV0aW9ucy1FQzI4XCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJEZXRhaWxlZCBtb25pdG9yaW5nIG5vdCByZXF1aXJlZCBmb3IgbG9jYWxuZXQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwiQXdzU29sdXRpb25zLUVDMjlcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIlRlcm1pbmF0aW9uIHByb3RlY3Rpb24gbm90IHJlcXVpcmVkIGZvciBsb2NhbG5ldCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgIH1cbn1cblxuIl19