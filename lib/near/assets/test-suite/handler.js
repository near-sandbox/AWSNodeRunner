"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = handler;
const near_api_js_1 = require("near-api-js");
const client_cloudwatch_1 = require("@aws-sdk/client-cloudwatch");
// Configuration from environment
const RPC_URL = process.env.RPC_URL;
const NETWORK_ID = process.env.NETWORK_ID || 'localnet';
const INCLUDE_WRITE_TESTS = process.env.INCLUDE_WRITE_TESTS === 'true';
const TEST_DEPTH = process.env.TEST_DEPTH || 'basic';
// Test results tracking
let testsPassed = 0;
let testsFailed = 0;
// CloudWatch client
const cloudwatch = new client_cloudwatch_1.CloudWatchClient({});
async function putMetric(metricName, value, unit = 'Count') {
    try {
        await cloudwatch.send(new client_cloudwatch_1.PutMetricDataCommand({
            Namespace: 'NEAR/Test',
            MetricData: [{
                    MetricName: metricName,
                    Value: value,
                    Unit: unit,
                    Dimensions: [{
                            Name: 'FunctionName',
                            Value: process.env.AWS_LAMBDA_FUNCTION_NAME || 'near-localnet-test'
                        }]
                }]
        }));
    }
    catch (error) {
        console.error(`Warning: Failed to put metric ${metricName}:`, error);
    }
}
function log(message) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${message}`);
}
async function runTest(name, testFn) {
    const startTime = Date.now();
    try {
        await testFn();
        const duration = Date.now() - startTime;
        testsPassed++;
        log(`✅ PASS: ${name} (${duration}ms)`);
        return true;
    }
    catch (error) {
        const duration = Date.now() - startTime;
        testsFailed++;
        log(`❌ FAIL: ${name} (${duration}ms)`);
        log(`Error: ${error instanceof Error ? error.message : String(error)}`);
        return false;
    }
}
async function runReadTests(provider) {
    log('=== Running Read-Only Tests ===');
    // Test 1: RPC Status
    await runTest('RPC Status', async () => {
        const status = await provider.status();
        if (!status.chain_id) {
            throw new Error('No chain_id in status');
        }
        log(`Chain ID: ${status.chain_id}`);
    });
    // Test 2: Latest Block
    await runTest('Latest Block', async () => {
        const block = await provider.block({ finality: 'final' });
        if (!block.header) {
            throw new Error('No block header');
        }
        log(`Block height: ${block.header.height}`);
    });
    // Test 3: Network Info
    await runTest('Network Info', async () => {
        const networkInfo = await provider.sendJsonRpc('network_info', []);
        if (!networkInfo) {
            throw new Error('No network info');
        }
        log(`Network info retrieved: ${JSON.stringify(networkInfo).substring(0, 100)}...`);
    });
    // Test 4: Query Account (node0 validator)
    await runTest('View System Account', async () => {
        const account = await provider.query({
            request_type: 'view_account',
            account_id: 'node0',
            finality: 'final'
        });
        if (!account || !account.amount) {
            throw new Error('Account not found or invalid');
        }
        log(`Account balance: ${near_api_js_1.utils.format.formatNearAmount(account.amount)} NEAR`);
    });
}
async function runWriteTests(provider, masterKey, masterAccountId) {
    if (!INCLUDE_WRITE_TESTS) {
        log('Skipping write tests (INCLUDE_WRITE_TESTS=false)');
        return;
    }
    log('=== Running Write Tests ===');
    // Create account ID and key pair outside test functions so they can be reused
    const testAccountId = `test-${Date.now()}.test.near`;
    const testKeyPair = near_api_js_1.KeyPair.fromRandom('ed25519');
    // Track if account creation succeeded for subsequent tests
    let accountCreated = false;
    // Test 1: Create Account
    const createAccountSuccess = await runTest('Create Test Account', async () => {
        // Connect to master account using near-api-js Account API
        const keyStore = new near_api_js_1.keyStores.InMemoryKeyStore();
        await keyStore.setKey(NETWORK_ID, masterAccountId, masterKey);
        const config = {
            networkId: NETWORK_ID,
            keyStore,
            nodeUrl: RPC_URL,
        };
        const near = await (0, near_api_js_1.connect)(config);
        const masterAccount = await near.account(masterAccountId);
        // Create subaccount with initial balance
        // For localnet, we can create a subaccount of node0 (e.g., test-123.test.near)
        const amount = near_api_js_1.utils.format.parseNearAmount('10');
        try {
            // Use Account.createAccount for simpler API
            const result = await masterAccount.createAccount(testAccountId, near_api_js_1.utils.PublicKey.from(testKeyPair.getPublicKey()), amount);
            log(`Account creation transaction: ${result.transaction.hash}`);
            // Wait for transaction to complete
            await new Promise(resolve => setTimeout(resolve, 3000));
            // Verify account was created
            const account = await provider.query({
                request_type: 'view_account',
                account_id: testAccountId,
                finality: 'final'
            });
            if (!account || !account.amount) {
                throw new Error('Account was not created successfully');
            }
            log(`Test account created: ${testAccountId} with balance ${near_api_js_1.utils.format.formatNearAmount(account.amount)} NEAR`);
        }
        catch (error) {
            // If createAccount fails (e.g., account already exists), try manual transaction
            log(`createAccount failed, trying manual transaction: ${error.message}`);
            // Get access key info for nonce
            const accessKey = await provider.query({
                request_type: 'view_access_key',
                account_id: masterAccountId,
                public_key: masterKey.getPublicKey().toString(),
                finality: 'final'
            });
            const nonce = (accessKey.nonce || 0) + 1;
            // Get latest block hash
            const block = await provider.block({ finality: 'final' });
            const blockHash = block.header.hash;
            // Create transaction to create account and transfer funds
            const createAccountAction = near_api_js_1.transactions.createAccount();
            const transferAction = near_api_js_1.transactions.transfer(amount);
            const addKeyAction = near_api_js_1.transactions.addKey(near_api_js_1.utils.PublicKey.from(testKeyPair.getPublicKey()), near_api_js_1.transactions.functionCallAccessKey(testAccountId, [], null));
            const tx = near_api_js_1.transactions.createTransaction(masterAccountId, near_api_js_1.utils.PublicKey.from(masterKey.getPublicKey()), testAccountId, nonce, [createAccountAction, transferAction, addKeyAction], blockHash);
            const signedTx = await near_api_js_1.transactions.signTransaction(tx, masterKey);
            const result = await provider.sendTransaction(signedTx);
            log(`Manual transaction hash: ${result.transaction.hash}`);
            // Wait for transaction to complete
            await new Promise(resolve => setTimeout(resolve, 3000));
            // Verify account was created
            const account = await provider.query({
                request_type: 'view_account',
                account_id: testAccountId,
                finality: 'final'
            });
            if (!account || !account.amount) {
                throw new Error('Account was not created successfully');
            }
            log(`Test account created via manual transaction: ${testAccountId}`);
        }
        accountCreated = true;
    });
    // Test 2: Send Transaction (if account created)
    if (accountCreated && TEST_DEPTH === 'comprehensive') {
        await runTest('Send Transaction', async () => {
            // Connect to the test account using the key pair we created
            const keyStore = new near_api_js_1.keyStores.InMemoryKeyStore();
            await keyStore.setKey(NETWORK_ID, testAccountId, testKeyPair);
            const config = {
                networkId: NETWORK_ID,
                keyStore,
                nodeUrl: RPC_URL,
            };
            const near = await (0, near_api_js_1.connect)(config);
            const testAccount = await near.account(testAccountId);
            // Transfer 1 NEAR back to node0
            const result = await testAccount.sendMoney(masterAccountId, near_api_js_1.utils.format.parseNearAmount('1'));
            log(`Transfer transaction hash: ${result.transaction.hash}`);
            // Wait for transaction to complete
            await new Promise(resolve => setTimeout(resolve, 2000));
            // Verify transfer by checking balances
            const receiverAccount = await provider.query({
                request_type: 'view_account',
                account_id: masterAccountId,
                finality: 'final'
            });
            log(`Receiver balance: ${near_api_js_1.utils.format.formatNearAmount(receiverAccount.amount)} NEAR`);
        });
    }
}
async function handler(event) {
    testsPassed = 0;
    testsFailed = 0;
    const startTime = Date.now();
    log('=== NEAR Localnet Test Suite ===');
    log(`RPC URL: ${RPC_URL}`);
    log(`Network ID: ${NETWORK_ID}`);
    log(`Include Write Tests: ${INCLUDE_WRITE_TESTS}`);
    log(`Test Depth: ${TEST_DEPTH}`);
    try {
        // Validate RPC URL
        if (!RPC_URL) {
            throw new Error('RPC_URL environment variable not set');
        }
        // Create JSON RPC provider
        const provider = new near_api_js_1.providers.JsonRpcProvider({ url: RPC_URL });
        // Measure RPC response time
        const rpcStart = Date.now();
        await provider.status();
        const rpcDuration = Date.now() - rpcStart;
        log(`RPC response time: ${rpcDuration}ms`);
        // Send CloudWatch metric
        await putMetric('RpcResponseTime', rpcDuration, 'Milliseconds');
        // Run read tests (always)
        await runReadTests(provider);
        // Run write tests (conditional, requires validator key)
        if (INCLUDE_WRITE_TESTS) {
            // Get validator key from environment
            const validatorKeyJson = process.env.VALIDATOR_KEY_JSON;
            if (validatorKeyJson) {
                try {
                    const keyData = JSON.parse(validatorKeyJson);
                    const secretKey = keyData.secret_key || keyData.private_key;
                    if (!secretKey) {
                        throw new Error('Invalid key format: missing secret_key or private_key');
                    }
                    // Handle both "ed25519:..." format and raw base64
                    let masterKey;
                    if (secretKey.startsWith('ed25519:')) {
                        masterKey = near_api_js_1.KeyPair.fromString(secretKey);
                    }
                    else {
                        // Assume it's base64 encoded
                        masterKey = near_api_js_1.KeyPair.fromString(`ed25519:${secretKey}`);
                    }
                    const masterAccountId = keyData.account_id || 'node0';
                    log(`Using validator key for account: ${masterAccountId}`);
                    await runWriteTests(provider, masterKey, masterAccountId);
                }
                catch (error) {
                    log(`WARNING: Failed to parse validator key: ${error instanceof Error ? error.message : String(error)}`);
                    log('Skipping write tests due to invalid validator key');
                }
            }
            else {
                log('WARNING: VALIDATOR_KEY_JSON not set, skipping write tests');
            }
        }
        // Send metrics
        const totalDuration = Date.now() - startTime;
        await putMetric('TestsPassed', testsPassed);
        await putMetric('TestsFailed', testsFailed);
        await putMetric('TestDuration', totalDuration, 'Milliseconds');
        // Summary
        log('=== Test Summary ===');
        log(`Total Tests: ${testsPassed + testsFailed}`);
        log(`Passed: ${testsPassed}`);
        log(`Failed: ${testsFailed}`);
        log(`Duration: ${totalDuration}ms`);
        if (testsFailed > 0) {
            const error = new Error(`${testsFailed} test(s) failed`);
            error.responseBody = {
                success: false,
                testsPassed,
                testsFailed,
                duration: totalDuration,
                message: `${testsFailed} test(s) failed`
            };
            throw error;
        }
        return {
            success: true,
            testsPassed,
            testsFailed,
            duration: totalDuration,
            message: 'All tests passed'
        };
    }
    catch (error) {
        log(`Test suite error: ${error instanceof Error ? error.message : String(error)}`);
        // Ensure metrics are sent even on error
        const totalDuration = Date.now() - startTime;
        await putMetric('TestsFailed', testsFailed || 1);
        await putMetric('TestDuration', totalDuration, 'Milliseconds');
        throw error;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUF1UUEsMEJBNEdDO0FBblhELDZDQUEwRjtBQUMxRixrRUFBb0Y7QUFFcEYsaUNBQWlDO0FBQ2pDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBUSxDQUFDO0FBQ3JDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQztBQUN4RCxNQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEtBQUssTUFBTSxDQUFDO0FBQ3ZFLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQztBQUVyRCx3QkFBd0I7QUFDeEIsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3BCLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztBQUVwQixvQkFBb0I7QUFDcEIsTUFBTSxVQUFVLEdBQUcsSUFBSSxvQ0FBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUU1QyxLQUFLLFVBQVUsU0FBUyxDQUFDLFVBQWtCLEVBQUUsS0FBYSxFQUFFLE9BQWUsT0FBTztJQUM5RSxJQUFJLENBQUM7UUFDRCxNQUFNLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSx3Q0FBb0IsQ0FBQztZQUMzQyxTQUFTLEVBQUUsV0FBVztZQUN0QixVQUFVLEVBQUUsQ0FBQztvQkFDVCxVQUFVLEVBQUUsVUFBVTtvQkFDdEIsS0FBSyxFQUFFLEtBQUs7b0JBQ1osSUFBSSxFQUFFLElBQUk7b0JBQ1YsVUFBVSxFQUFFLENBQUM7NEJBQ1QsSUFBSSxFQUFFLGNBQWM7NEJBQ3BCLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUF3QixJQUFJLG9CQUFvQjt5QkFDdEUsQ0FBQztpQkFDTCxDQUFDO1NBQ0wsQ0FBQyxDQUFDLENBQUM7SUFD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QUFLLENBQUM7UUFDaEIsQ0FBQztRQUVELE9BQU87WUFDSCxPQUFPLEVBQUUsSUFBSTtZQUNiLFdBQVc7WUFDWCxXQUFXO1lBQ1gsUUFBUSxFQUFFLGFBQWE7WUFDdkIsT0FBTyxFQUFFLGtCQUFrQjtTQUM5QixDQUFDO0lBQ04sQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDYixHQUFHLENBQUMscUJBQXFCLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFbkYsd0NBQXdDO1FBQ3hDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7UUFDN0MsTUFBTSxTQUFTLENBQUMsYUFBYSxFQUFFLFdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNqRCxNQUFNLFNBQVMsQ0FBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRS9ELE1BQU0sS0FBSyxDQUFDO0lBQ2hCLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29ubmVjdCwga2V5U3RvcmVzLCBLZXlQYWlyLCBwcm92aWRlcnMsIHRyYW5zYWN0aW9ucywgdXRpbHMgfSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBDbG91ZFdhdGNoQ2xpZW50LCBQdXRNZXRyaWNEYXRhQ29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZHdhdGNoJztcblxuLy8gQ29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50XG5jb25zdCBSUENfVVJMID0gcHJvY2Vzcy5lbnYuUlBDX1VSTCE7XG5jb25zdCBORVRXT1JLX0lEID0gcHJvY2Vzcy5lbnYuTkVUV09SS19JRCB8fCAnbG9jYWxuZXQnO1xuY29uc3QgSU5DTFVERV9XUklURV9URVNUUyA9IHByb2Nlc3MuZW52LklOQ0xVREVfV1JJVEVfVEVTVFMgPT09ICd0cnVlJztcbmNvbnN0IFRFU1RfREVQVEggPSBwcm9jZXNzLmVudi5URVNUX0RFUFRIIHx8ICdiYXNpYyc7XG5cbi8vIFRlc3QgcmVzdWx0cyB0cmFja2luZ1xubGV0IHRlc3RzUGFzc2VkID0gMDtcbmxldCB0ZXN0c0ZhaWxlZCA9IDA7XG5cbi8vIENsb3VkV2F0Y2ggY2xpZW50XG5jb25zdCBjbG91ZHdhdGNoID0gbmV3IENsb3VkV2F0Y2hDbGllbnQoe30pO1xuXG5hc3luYyBmdW5jdGlvbiBwdXRNZXRyaWMobWV0cmljTmFtZTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyLCB1bml0OiBzdHJpbmcgPSAnQ291bnQnKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xvdWR3YXRjaC5zZW5kKG5ldyBQdXRNZXRyaWNEYXRhQ29tbWFuZCh7XG4gICAgICAgICAgICBOYW1lc3BhY2U6ICdORUFSL1Rlc3QnLFxuICAgICAgICAgICAgTWV0cmljRGF0YTogW3tcbiAgICAgICAgICAgICAgICBNZXRyaWNOYW1lOiBtZXRyaWNOYW1lLFxuICAgICAgICAgICAgICAgIFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBVbml0OiB1bml0LFxuICAgICAgICAgICAgICAgIERpbWVuc2lvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIE5hbWU6ICdGdW5jdGlvbk5hbWUnLFxuICAgICAgICAgICAgICAgICAgICBWYWx1ZTogcHJvY2Vzcy5lbnYuQVdTX0xBTUJEQV9GVU5DVElPTl9OQU1FIHx8ICduZWFyLWxvY2FsbmV0LXRlc3QnXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiBGYWlsZWQgdG8gcHV0IG1ldHJpYyAke21ldHJpY05hbWV9OmAsIGVycm9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvZyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc29sZS5sb2coYFske3RpbWVzdGFtcH1dICR7bWVzc2FnZX1gKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuVGVzdChuYW1lOiBzdHJpbmcsIHRlc3RGbjogKCkgPT4gUHJvbWlzZTx2b2lkPik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGVzdEZuKCk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgdGVzdHNQYXNzZWQrKztcbiAgICAgICAgbG9nKGDinIUgUEFTUzogJHtuYW1lfSAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0ZXN0c0ZhaWxlZCsrO1xuICAgICAgICBsb2coYOKdjCBGQUlMOiAke25hbWV9ICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICBsb2coYEVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuUmVhZFRlc3RzKHByb3ZpZGVyOiBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nKCc9PT0gUnVubmluZyBSZWFkLU9ubHkgVGVzdHMgPT09Jyk7XG4gICAgXG4gICAgLy8gVGVzdCAxOiBSUEMgU3RhdHVzXG4gICAgYXdhaXQgcnVuVGVzdCgnUlBDIFN0YXR1cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgcHJvdmlkZXIuc3RhdHVzKCk7XG4gICAgICAgIGlmICghc3RhdHVzLmNoYWluX2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNoYWluX2lkIGluIHN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGxvZyhgQ2hhaW4gSUQ6ICR7c3RhdHVzLmNoYWluX2lkfWApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFRlc3QgMjogTGF0ZXN0IEJsb2NrXG4gICAgYXdhaXQgcnVuVGVzdCgnTGF0ZXN0IEJsb2NrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmJsb2NrKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgIGlmICghYmxvY2suaGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGJsb2NrIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGxvZyhgQmxvY2sgaGVpZ2h0OiAke2Jsb2NrLmhlYWRlci5oZWlnaHR9YCk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVGVzdCAzOiBOZXR3b3JrIEluZm9cbiAgICBhd2FpdCBydW5UZXN0KCdOZXR3b3JrIEluZm8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJbmZvID0gYXdhaXQgcHJvdmlkZXIuc2VuZEpzb25ScGMoJ25ldHdvcmtfaW5mbycsIFtdKTtcbiAgICAgICAgaWYgKCFuZXR3b3JrSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXR3b3JrIGluZm8nKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coYE5ldHdvcmsgaW5mbyByZXRyaWV2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkobmV0d29ya0luZm8pLnN1YnN0cmluZygwLCAxMDApfS4uLmApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFRlc3QgNDogUXVlcnkgQWNjb3VudCAobm9kZTAgdmFsaWRhdG9yKVxuICAgIGF3YWl0IHJ1blRlc3QoJ1ZpZXcgU3lzdGVtIEFjY291bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBwcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2FjY291bnQnLFxuICAgICAgICAgICAgYWNjb3VudF9pZDogJ25vZGUwJyxcbiAgICAgICAgICAgIGZpbmFsaXR5OiAnZmluYWwnXG4gICAgICAgIH0pIGFzIGFueTtcbiAgICAgICAgaWYgKCFhY2NvdW50IHx8ICFhY2NvdW50LmFtb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCBvciBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKGBBY2NvdW50IGJhbGFuY2U6ICR7dXRpbHMuZm9ybWF0LmZvcm1hdE5lYXJBbW91bnQoYWNjb3VudC5hbW91bnQpfSBORUFSYCk7XG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bldyaXRlVGVzdHMoXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIsXG4gICAgbWFzdGVyS2V5OiBLZXlQYWlyLFxuICAgIG1hc3RlckFjY291bnRJZDogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlOQ0xVREVfV1JJVEVfVEVTVFMpIHtcbiAgICAgICAgbG9nKCdTa2lwcGluZyB3cml0ZSB0ZXN0cyAoSU5DTFVERV9XUklURV9URVNUUz1mYWxzZSknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBsb2coJz09PSBSdW5uaW5nIFdyaXRlIFRlc3RzID09PScpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhY2NvdW50IElEIGFuZCBrZXkgcGFpciBvdXRzaWRlIHRlc3QgZnVuY3Rpb25zIHNvIHRoZXkgY2FuIGJlIHJldXNlZFxuICAgIGNvbnN0IHRlc3RBY2NvdW50SWQgPSBgdGVzdC0ke0RhdGUubm93KCl9LnRlc3QubmVhcmA7XG4gICAgY29uc3QgdGVzdEtleVBhaXIgPSBLZXlQYWlyLmZyb21SYW5kb20oJ2VkMjU1MTknKTtcbiAgICBcbiAgICAvLyBUcmFjayBpZiBhY2NvdW50IGNyZWF0aW9uIHN1Y2NlZWRlZCBmb3Igc3Vic2VxdWVudCB0ZXN0c1xuICAgIGxldCBhY2NvdW50Q3JlYXRlZCA9IGZhbHNlO1xuICAgIFxuICAgIC8vIFRlc3QgMTogQ3JlYXRlIEFjY291bnRcbiAgICBjb25zdCBjcmVhdGVBY2NvdW50U3VjY2VzcyA9IGF3YWl0IHJ1blRlc3QoJ0NyZWF0ZSBUZXN0IEFjY291bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIENvbm5lY3QgdG8gbWFzdGVyIGFjY291bnQgdXNpbmcgbmVhci1hcGktanMgQWNjb3VudCBBUElcbiAgICAgICAgY29uc3Qga2V5U3RvcmUgPSBuZXcga2V5U3RvcmVzLkluTWVtb3J5S2V5U3RvcmUoKTtcbiAgICAgICAgYXdhaXQga2V5U3RvcmUuc2V0S2V5KE5FVFdPUktfSUQsIG1hc3RlckFjY291bnRJZCwgbWFzdGVyS2V5KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5ldHdvcmtJZDogTkVUV09SS19JRCxcbiAgICAgICAgICAgIGtleVN0b3JlLFxuICAgICAgICAgICAgbm9kZVVybDogUlBDX1VSTCxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5lYXIgPSBhd2FpdCBjb25uZWN0KGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG1hc3RlckFjY291bnQgPSBhd2FpdCBuZWFyLmFjY291bnQobWFzdGVyQWNjb3VudElkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBzdWJhY2NvdW50IHdpdGggaW5pdGlhbCBiYWxhbmNlXG4gICAgICAgIC8vIEZvciBsb2NhbG5ldCwgd2UgY2FuIGNyZWF0ZSBhIHN1YmFjY291bnQgb2Ygbm9kZTAgKGUuZy4sIHRlc3QtMTIzLnRlc3QubmVhcilcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdXRpbHMuZm9ybWF0LnBhcnNlTmVhckFtb3VudCgnMTAnKSE7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIEFjY291bnQuY3JlYXRlQWNjb3VudCBmb3Igc2ltcGxlciBBUElcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1hc3RlckFjY291bnQuY3JlYXRlQWNjb3VudChcbiAgICAgICAgICAgICAgICB0ZXN0QWNjb3VudElkLFxuICAgICAgICAgICAgICAgIHV0aWxzLlB1YmxpY0tleS5mcm9tKHRlc3RLZXlQYWlyLmdldFB1YmxpY0tleSgpKSxcbiAgICAgICAgICAgICAgICBhbW91bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxvZyhgQWNjb3VudCBjcmVhdGlvbiB0cmFuc2FjdGlvbjogJHtyZXN1bHQudHJhbnNhY3Rpb24uaGFzaH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gdG8gY29tcGxldGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFZlcmlmeSBhY2NvdW50IHdhcyBjcmVhdGVkXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcHJvdmlkZXIucXVlcnkoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjb3VudCcsXG4gICAgICAgICAgICAgICAgYWNjb3VudF9pZDogdGVzdEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ2ZpbmFsJ1xuICAgICAgICAgICAgfSkgYXMgYW55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWFjY291bnQgfHwgIWFjY291bnQuYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IHdhcyBub3QgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbG9nKGBUZXN0IGFjY291bnQgY3JlYXRlZDogJHt0ZXN0QWNjb3VudElkfSB3aXRoIGJhbGFuY2UgJHt1dGlscy5mb3JtYXQuZm9ybWF0TmVhckFtb3VudChhY2NvdW50LmFtb3VudCl9IE5FQVJgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgLy8gSWYgY3JlYXRlQWNjb3VudCBmYWlscyAoZS5nLiwgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyksIHRyeSBtYW51YWwgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGxvZyhgY3JlYXRlQWNjb3VudCBmYWlsZWQsIHRyeWluZyBtYW51YWwgdHJhbnNhY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IGFjY2VzcyBrZXkgaW5mbyBmb3Igbm9uY2VcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IGF3YWl0IHByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2FjY2Vzc19rZXknLFxuICAgICAgICAgICAgICAgIGFjY291bnRfaWQ6IG1hc3RlckFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBtYXN0ZXJLZXkuZ2V0UHVibGljS2V5KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ2ZpbmFsJ1xuICAgICAgICAgICAgfSkgYXMgYW55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IChhY2Nlc3NLZXkubm9uY2UgfHwgMCkgKyAxO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZXQgbGF0ZXN0IGJsb2NrIGhhc2hcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IGJsb2NrLmhlYWRlci5oYXNoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gdG8gY3JlYXRlIGFjY291bnQgYW5kIHRyYW5zZmVyIGZ1bmRzXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVBY2NvdW50QWN0aW9uID0gdHJhbnNhY3Rpb25zLmNyZWF0ZUFjY291bnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyQWN0aW9uID0gdHJhbnNhY3Rpb25zLnRyYW5zZmVyKGFtb3VudCk7XG4gICAgICAgICAgICBjb25zdCBhZGRLZXlBY3Rpb24gPSB0cmFuc2FjdGlvbnMuYWRkS2V5KFxuICAgICAgICAgICAgICAgIHV0aWxzLlB1YmxpY0tleS5mcm9tKHRlc3RLZXlQYWlyLmdldFB1YmxpY0tleSgpKSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMuZnVuY3Rpb25DYWxsQWNjZXNzS2V5KHRlc3RBY2NvdW50SWQsIFtdLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdHggPSB0cmFuc2FjdGlvbnMuY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICAgICAgbWFzdGVyQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIHV0aWxzLlB1YmxpY0tleS5mcm9tKG1hc3RlcktleS5nZXRQdWJsaWNLZXkoKSksXG4gICAgICAgICAgICAgICAgdGVzdEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBbY3JlYXRlQWNjb3VudEFjdGlvbiwgdHJhbnNmZXJBY3Rpb24sIGFkZEtleUFjdGlvbl0sXG4gICAgICAgICAgICAgICAgYmxvY2tIYXNoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRyYW5zYWN0aW9ucy5zaWduVHJhbnNhY3Rpb24odHgsIG1hc3RlcktleSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsb2coYE1hbnVhbCB0cmFuc2FjdGlvbiBoYXNoOiAke3Jlc3VsdC50cmFuc2FjdGlvbi5oYXNofWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmVyaWZ5IGFjY291bnQgd2FzIGNyZWF0ZWRcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBwcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0ZXN0QWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGZpbmFsaXR5OiAnZmluYWwnXG4gICAgICAgICAgICB9KSBhcyBhbnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghYWNjb3VudCB8fCAhYWNjb3VudC5hbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgd2FzIG5vdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsb2coYFRlc3QgYWNjb3VudCBjcmVhdGVkIHZpYSBtYW51YWwgdHJhbnNhY3Rpb246ICR7dGVzdEFjY291bnRJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYWNjb3VudENyZWF0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFRlc3QgMjogU2VuZCBUcmFuc2FjdGlvbiAoaWYgYWNjb3VudCBjcmVhdGVkKVxuICAgIGlmIChhY2NvdW50Q3JlYXRlZCAmJiBURVNUX0RFUFRIID09PSAnY29tcHJlaGVuc2l2ZScpIHtcbiAgICAgICAgYXdhaXQgcnVuVGVzdCgnU2VuZCBUcmFuc2FjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIHRlc3QgYWNjb3VudCB1c2luZyB0aGUga2V5IHBhaXIgd2UgY3JlYXRlZFxuICAgICAgICAgICAgY29uc3Qga2V5U3RvcmUgPSBuZXcga2V5U3RvcmVzLkluTWVtb3J5S2V5U3RvcmUoKTtcbiAgICAgICAgICAgIGF3YWl0IGtleVN0b3JlLnNldEtleShORVRXT1JLX0lELCB0ZXN0QWNjb3VudElkLCB0ZXN0S2V5UGFpcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSUQsXG4gICAgICAgICAgICAgICAga2V5U3RvcmUsXG4gICAgICAgICAgICAgICAgbm9kZVVybDogUlBDX1VSTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG5lYXIgPSBhd2FpdCBjb25uZWN0KGNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0QWNjb3VudCA9IGF3YWl0IG5lYXIuYWNjb3VudCh0ZXN0QWNjb3VudElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVHJhbnNmZXIgMSBORUFSIGJhY2sgdG8gbm9kZTBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RBY2NvdW50LnNlbmRNb25leShcbiAgICAgICAgICAgICAgICBtYXN0ZXJBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgdXRpbHMuZm9ybWF0LnBhcnNlTmVhckFtb3VudCgnMScpIVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbG9nKGBUcmFuc2ZlciB0cmFuc2FjdGlvbiBoYXNoOiAke3Jlc3VsdC50cmFuc2FjdGlvbi5oYXNofWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRyYW5zZmVyIGJ5IGNoZWNraW5nIGJhbGFuY2VzXG4gICAgICAgICAgICBjb25zdCByZWNlaXZlckFjY291bnQgPSBhd2FpdCBwcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiBtYXN0ZXJBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgZmluYWxpdHk6ICdmaW5hbCdcbiAgICAgICAgICAgIH0pIGFzIGFueTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbG9nKGBSZWNlaXZlciBiYWxhbmNlOiAke3V0aWxzLmZvcm1hdC5mb3JtYXROZWFyQW1vdW50KHJlY2VpdmVyQWNjb3VudC5hbW91bnQpfSBORUFSYCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQ6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdGVzdHNQYXNzZWQgPSAwO1xuICAgIHRlc3RzRmFpbGVkID0gMDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIGxvZygnPT09IE5FQVIgTG9jYWxuZXQgVGVzdCBTdWl0ZSA9PT0nKTtcbiAgICBsb2coYFJQQyBVUkw6ICR7UlBDX1VSTH1gKTtcbiAgICBsb2coYE5ldHdvcmsgSUQ6ICR7TkVUV09SS19JRH1gKTtcbiAgICBsb2coYEluY2x1ZGUgV3JpdGUgVGVzdHM6ICR7SU5DTFVERV9XUklURV9URVNUU31gKTtcbiAgICBsb2coYFRlc3QgRGVwdGg6ICR7VEVTVF9ERVBUSH1gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBSUEMgVVJMXG4gICAgICAgIGlmICghUlBDX1VSTCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSUENfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIEpTT04gUlBDIHByb3ZpZGVyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIoeyB1cmw6IFJQQ19VUkwgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNZWFzdXJlIFJQQyByZXNwb25zZSB0aW1lXG4gICAgICAgIGNvbnN0IHJwY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIuc3RhdHVzKCk7XG4gICAgICAgIGNvbnN0IHJwY0R1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHJwY1N0YXJ0O1xuICAgICAgICBsb2coYFJQQyByZXNwb25zZSB0aW1lOiAke3JwY0R1cmF0aW9ufW1zYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZW5kIENsb3VkV2F0Y2ggbWV0cmljXG4gICAgICAgIGF3YWl0IHB1dE1ldHJpYygnUnBjUmVzcG9uc2VUaW1lJywgcnBjRHVyYXRpb24sICdNaWxsaXNlY29uZHMnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJ1biByZWFkIHRlc3RzIChhbHdheXMpXG4gICAgICAgIGF3YWl0IHJ1blJlYWRUZXN0cyhwcm92aWRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBSdW4gd3JpdGUgdGVzdHMgKGNvbmRpdGlvbmFsLCByZXF1aXJlcyB2YWxpZGF0b3Iga2V5KVxuICAgICAgICBpZiAoSU5DTFVERV9XUklURV9URVNUUykge1xuICAgICAgICAgICAgLy8gR2V0IHZhbGlkYXRvciBrZXkgZnJvbSBlbnZpcm9ubWVudFxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yS2V5SnNvbiA9IHByb2Nlc3MuZW52LlZBTElEQVRPUl9LRVlfSlNPTjtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3JLZXlKc29uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5RGF0YSA9IEpTT04ucGFyc2UodmFsaWRhdG9yS2V5SnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3JldEtleSA9IGtleURhdGEuc2VjcmV0X2tleSB8fCBrZXlEYXRhLnByaXZhdGVfa2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlY3JldEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBmb3JtYXQ6IG1pc3Npbmcgc2VjcmV0X2tleSBvciBwcml2YXRlX2tleScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCBcImVkMjU1MTk6Li4uXCIgZm9ybWF0IGFuZCByYXcgYmFzZTY0XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXN0ZXJLZXk6IEtleVBhaXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWNyZXRLZXkuc3RhcnRzV2l0aCgnZWQyNTUxOTonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyS2V5ID0gS2V5UGFpci5mcm9tU3RyaW5nKHNlY3JldEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgaXQncyBiYXNlNjQgZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyS2V5ID0gS2V5UGFpci5mcm9tU3RyaW5nKGBlZDI1NTE5OiR7c2VjcmV0S2V5fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJBY2NvdW50SWQgPSBrZXlEYXRhLmFjY291bnRfaWQgfHwgJ25vZGUwJztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxvZyhgVXNpbmcgdmFsaWRhdG9yIGtleSBmb3IgYWNjb3VudDogJHttYXN0ZXJBY2NvdW50SWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bldyaXRlVGVzdHMocHJvdmlkZXIsIG1hc3RlcktleSwgbWFzdGVyQWNjb3VudElkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2coYFdBUk5JTkc6IEZhaWxlZCB0byBwYXJzZSB2YWxpZGF0b3Iga2V5OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdTa2lwcGluZyB3cml0ZSB0ZXN0cyBkdWUgdG8gaW52YWxpZCB2YWxpZGF0b3Iga2V5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2coJ1dBUk5JTkc6IFZBTElEQVRPUl9LRVlfSlNPTiBub3Qgc2V0LCBza2lwcGluZyB3cml0ZSB0ZXN0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZW5kIG1ldHJpY3NcbiAgICAgICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIGF3YWl0IHB1dE1ldHJpYygnVGVzdHNQYXNzZWQnLCB0ZXN0c1Bhc3NlZCk7XG4gICAgICAgIGF3YWl0IHB1dE1ldHJpYygnVGVzdHNGYWlsZWQnLCB0ZXN0c0ZhaWxlZCk7XG4gICAgICAgIGF3YWl0IHB1dE1ldHJpYygnVGVzdER1cmF0aW9uJywgdG90YWxEdXJhdGlvbiwgJ01pbGxpc2Vjb25kcycpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3VtbWFyeVxuICAgICAgICBsb2coJz09PSBUZXN0IFN1bW1hcnkgPT09Jyk7XG4gICAgICAgIGxvZyhgVG90YWwgVGVzdHM6ICR7dGVzdHNQYXNzZWQgKyB0ZXN0c0ZhaWxlZH1gKTtcbiAgICAgICAgbG9nKGBQYXNzZWQ6ICR7dGVzdHNQYXNzZWR9YCk7XG4gICAgICAgIGxvZyhgRmFpbGVkOiAke3Rlc3RzRmFpbGVkfWApO1xuICAgICAgICBsb2coYER1cmF0aW9uOiAke3RvdGFsRHVyYXRpb259bXNgKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0ZXN0c0ZhaWxlZCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke3Rlc3RzRmFpbGVkfSB0ZXN0KHMpIGZhaWxlZGApO1xuICAgICAgICAgICAgKGVycm9yIGFzIGFueSkucmVzcG9uc2VCb2R5ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRlc3RzUGFzc2VkLFxuICAgICAgICAgICAgICAgIHRlc3RzRmFpbGVkLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0b3RhbER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3Rlc3RzRmFpbGVkfSB0ZXN0KHMpIGZhaWxlZGBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB0ZXN0c1Bhc3NlZCxcbiAgICAgICAgICAgIHRlc3RzRmFpbGVkLFxuICAgICAgICAgICAgZHVyYXRpb246IHRvdGFsRHVyYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiAnQWxsIHRlc3RzIHBhc3NlZCdcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2coYFRlc3Qgc3VpdGUgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIG1ldHJpY3MgYXJlIHNlbnQgZXZlbiBvbiBlcnJvclxuICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgYXdhaXQgcHV0TWV0cmljKCdUZXN0c0ZhaWxlZCcsIHRlc3RzRmFpbGVkIHx8IDEpO1xuICAgICAgICBhd2FpdCBwdXRNZXRyaWMoJ1Rlc3REdXJhdGlvbicsIHRvdGFsRHVyYXRpb24sICdNaWxsaXNlY29uZHMnKTtcbiAgICAgICAgXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbiJdfQ==