"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearInfrastructureStack = void 0;
const cdk = __importStar(require("aws-cdk-lib"));
const ec2 = __importStar(require("aws-cdk-lib/aws-ec2"));
const nag = __importStar(require("cdk-nag"));
class NearInfrastructureStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const REGION = cdk.Stack.of(this).region;
        const STACK_NAME = cdk.Stack.of(this).stackName;
        const STACK_ID = cdk.Stack.of(this).stackId;
        const { instanceType, instanceCpuType, nearNetwork, nearVersion, dataVolume, vpc, securityGroup, instanceRole, } = props;
        // Use provided VPC/security group/role or import from common stack
        if (vpc && securityGroup && instanceRole) {
            this.vpc = vpc;
            this.securityGroup = securityGroup;
            this.instanceRole = instanceRole;
        }
        else {
            // Fallback to imports (for cross-stack references when stacks are in different apps)
            const vpcId = cdk.Fn.importValue("NearLocalnetVpcId");
            const securityGroupId = cdk.Fn.importValue("NearLocalnetSecurityGroupId");
            const importedInstanceRoleArn = cdk.Fn.importValue("NearLocalnetInstanceRoleArn");
            // Note: Vpc.fromLookup requires environment context and won't work with imported values
            // This fallback is for reference but should use direct references in app.ts
            throw new Error("VPC, security group, and instance role must be provided directly when stacks are in the same app");
        }
        // Ubuntu 24.04 LTS image for amd64 (x86_64 required for NEAR)
        let ubuntuStableImageSsmName = "/aws/service/canonical/ubuntu/server/24.04/stable/current/amd64/hvm/ebs-gp3/ami-id";
        if (instanceCpuType === "arm64") {
            ubuntuStableImageSsmName = "/aws/service/canonical/ubuntu/server/24.04/stable/current/arm64/hvm/ebs-gp3/ami-id";
        }
        const machineImage = ec2.MachineImage.fromSsmParameter(ubuntuStableImageSsmName);
        // Parse instance type - CDK expects InstanceClass enum and InstanceSize enum
        // "t3.large" -> InstanceClass.T3, InstanceSize.LARGE
        const [instanceClassStr, instanceSizeStr] = instanceType.toLowerCase().split(".");
        // Convert "t3" -> "T3" for InstanceClass enum
        const instanceClass = (instanceClassStr.charAt(0).toUpperCase() + instanceClassStr.slice(1)).toUpperCase();
        const instanceSize = instanceSizeStr.toUpperCase();
        const ec2InstanceType = new ec2.InstanceType(`${instanceClassStr}.${instanceSizeStr}`);
        // UserData script following the working implementation from chain-mobil/cdk
        // This compiles and runs neard on Ubuntu per NEAR's recommendations
        // Modified to add localnet root account to genesis for .localnet naming parity
        // Force replacement: 2025-12-30T05:35:00Z
        const userData = ec2.UserData.forLinux();
        userData.addCommands('#!/bin/bash', 'set -e', 'exec > >(tee /var/log/near-setup.log) 2>&1', '', '# Force replacement timestamp: 2025-12-30T05:35:00Z', '', '# Update system', 'apt update', '', '# Install dependencies for NEAR compilation (Ubuntu packages)', 
        // NOTE: Ubuntu 24.04 no longer provides an `awscli` apt candidate in some images/repos.
        // Install AWS CLI via pip below.
        'apt install -y git binutils-dev libcurl4-openssl-dev zlib1g-dev libdw-dev libiberty-dev cmake gcc g++ python3 python3-pip protobuf-compiler libssl-dev pkg-config clang llvm jq', '', '# Install Rust as ubuntu user', 'su - ubuntu -c "curl --proto =https --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"', 'su - ubuntu -c "source ~/.cargo/env && rustc --version"', '', '# Clone nearcore', 'su - ubuntu -c "cd ~ && git clone https://github.com/near/nearcore.git"', `su - ubuntu -c "cd ~/nearcore && git checkout ${nearVersion}"`, '', '# Compile neard (takes ~10-15 minutes)', 'su - ubuntu -c "cd ~/nearcore && source ~/.cargo/env && make neard"', '', '# Install nearup (Ubuntu 24.04 requires --break-system-packages)', 'su - ubuntu -c "pip3 install --user --break-system-packages nearup"', '', '# Install AWS CLI (required for writing SSM parameters during bootstrap)', 'pip3 install --break-system-packages awscli', 'aws --version || true', '', '# Run nearup localnet with compiled binary (creates genesis.json)', 'su - ubuntu -c "export PATH=$PATH:~/.local/bin && nearup run localnet --binary-path ~/nearcore/target/release" > /var/log/nearup.log 2>&1 &', '', '# Wait for genesis.json to be created by nearup', 'echo "Waiting for genesis.json to be created..."', 'for i in {1..60}; do', '  if [ -f /home/ubuntu/.near/localnet/node0/genesis.json ]; then', '    echo "Genesis file found"', '    break', '  fi', '  sleep 2', 'done', '', '# Stop nearup and all neard processes before patching genesis', 'echo "Stopping nearup and neard processes..."', 
        // Stop any running nearup/neard processes before patching genesis.
        // Run as root to avoid permission issues (nearup is started via a root-owned su wrapper).
        'pkill -f nearup || true', 'pkill -f neard || true', 'sleep 5', '', '# Generate localnet keypair using neard init (works in neard 2.10.1)', 'echo "Generating localnet keypair using neard init..."', 'su - ubuntu -c "rm -rf ~/.near/localnet-keygen && mkdir -p ~/.near/localnet-keygen"', 'su - ubuntu -c "~/nearcore/target/release/neard --home ~/.near/localnet-keygen init --account-id localnet --chain-id localnet --fast"', '', '# Extract public and secret keys from validator_key.json', 'LOCALNET_KEY_FILE="/home/ubuntu/.near/localnet-keygen/validator_key.json"', 'if [ ! -f "$LOCALNET_KEY_FILE" ]; then', '  echo "ERROR: validator_key.json not found after neard init"', '  exit 1', 'fi', 'LOCALNET_PUBLIC_KEY=$(su - ubuntu -c "cat $LOCALNET_KEY_FILE | jq -r \'.public_key\'" 2>/dev/null || echo "")', 'LOCALNET_SECRET_KEY=$(su - ubuntu -c "cat $LOCALNET_KEY_FILE | jq -r \'.secret_key\'" 2>/dev/null || echo "")', '', 'if [ -z "$LOCALNET_PUBLIC_KEY" ] || [ -z "$LOCALNET_SECRET_KEY" ] || [ "$LOCALNET_PUBLIC_KEY" = "null" ] || [ "$LOCALNET_SECRET_KEY" = "null" ]; then', '  echo "ERROR: Could not extract localnet keys from validator_key.json"', '  exit 1', 'fi', '', '# Create Python script for genesis patching with reallocation', 'cat > /tmp/patch-genesis-localnet.py << \'PYEOF\'', '#!/usr/bin/env python3', 'import json', 'import sys', '', 'if len(sys.argv) != 5:', '    print("Usage: patch-genesis-localnet.py <genesis.json> <public_key> <transfer_amount> <output.json>")', '    sys.exit(1)', '', 'genesis_path = sys.argv[1]', 'public_key = sys.argv[2]', 'transfer_amount = sys.argv[3]', 'output_path = sys.argv[4]', '', 'with open(genesis_path, \'r\') as f:', '    genesis = json.load(f)', '', '# Find node0 Account record and subtract transfer_amount', 'node0_found = False', 'for record in genesis.get(\'records\', []):', '    if \'Account\' in record:', '        account = record[\'Account\']', '        if account.get(\'account_id\') == \'node0\':', '            node0_found = True', '            current_amount = int(account[\'account\'][\'amount\'])', '            new_amount = current_amount - int(transfer_amount)', '            if new_amount < 0:', '                print(f"ERROR: node0 balance ({current_amount}) insufficient for transfer ({transfer_amount})")', '                sys.exit(1)', '            account[\'account\'][\'amount\'] = str(new_amount)', '            print(f"Reallocated {transfer_amount} yoctoNEAR from node0 (new balance: {new_amount})")', '            break', '', 'if not node0_found:', '    print("ERROR: node0 Account record not found in genesis")', '    sys.exit(1)', '', '# Add localnet Account record', 'localnet_account_record = {', '    "Account": {', '        "account_id": "localnet",', '        "account": {', '            "amount": transfer_amount,', '            "locked": "0",', '            "code_hash": "11111111111111111111111111111111",', '            "storage_usage": 182,', '            "version": "V1"', '        }', '    }', '}', 'genesis[\'records\'].append(localnet_account_record)', '', '# Add localnet AccessKey record', 'localnet_access_key_record = {', '    "AccessKey": {', '        "account_id": "localnet",', '        "public_key": public_key,', '        "access_key": {', '            "nonce": 0,', '            "permission": "FullAccess"', '        }', '    }', '}', 'genesis[\'records\'].append(localnet_access_key_record)', '', 'with open(output_path, \'w\') as f:', '    json.dump(genesis, f, indent=2)', '', 'print(f"Genesis patched successfully: {output_path}")', 'PYEOF', 'chmod +x /tmp/patch-genesis-localnet.py', '', '# Patch genesis.json with reallocation from node0', 'echo "Patching genesis.json with localnet account (reallocating from node0)..."', 'GENESIS_PATH="/home/ubuntu/.near/localnet/node0/genesis.json"', 'AMOUNT="100000000000000000000000000000"  # 100,000 NEAR', '', '# Backup genesis', 'su - ubuntu -c "cp $GENESIS_PATH ${GENESIS_PATH}.backup.$(date +%s)"', '', '# Run Python script to patch genesis', 'python3 /tmp/patch-genesis-localnet.py "$GENESIS_PATH" "$LOCALNET_PUBLIC_KEY" "$AMOUNT" /tmp/genesis_patched.json', '', '# Replace genesis for all nodes', 'for node in node0 node1 node2 node3; do', '  if [ -d /home/ubuntu/.near/localnet/$node ]; then', '    su - ubuntu -c "cp /tmp/genesis_patched.json /home/ubuntu/.near/localnet/$node/genesis.json"', '    echo "Updated genesis for $node"', '  fi', 'done', '', '# Remove node data directories so nodes start cleanly with patched genesis', 'echo "Removing node data directories for clean start..."', 'for node in node0 node1 node2 node3; do', '  if [ -d /home/ubuntu/.near/localnet/$node/data ]; then', '    su - ubuntu -c "rm -rf /home/ubuntu/.near/localnet/$node/data"', '    echo "Removed data directory for $node"', '  fi', 'done', '', '# Store localnet keypair in SSM Parameter Store', 'echo "Storing localnet keypair in SSM..."', '# IMDSv2-safe region discovery', 'TOKEN=$(curl -sS -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" || true)', 'if [ -n "$TOKEN" ]; then', '  AWS_REGION=$(curl -sS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)', 'else', '  AWS_REGION=$(curl -sS http://169.254.169.254/latest/meta-data/placement/region)', 'fi', 'aws ssm put-parameter --name "/near-localnet/localnet-account-key" --value "$LOCALNET_SECRET_KEY" --type "SecureString" --overwrite --region "$AWS_REGION" || true', 'aws ssm put-parameter --name "/near-localnet/localnet-account-id" --value "localnet" --type "String" --overwrite --region "$AWS_REGION" || true', 'echo "Localnet keypair stored in SSM"', '', '# Start neard processes directly (not via nearup)', 'echo "Starting neard processes with patched genesis..."', '# Get node0 boot node public key', 'BOOT_PUB=$(su - ubuntu -c "cat ~/.near/localnet/node0/node_key.json | jq -r \'.public_key\'")', 'BOOT_NODE="${BOOT_PUB}@127.0.0.1:24567"', '', '# Start node0', 'su - ubuntu -c "nohup ~/nearcore/target/release/neard --home ~/.near/localnet/node0 run > ~/neard-node0.log 2>&1 &"', 'sleep 2', '', '# Start node1, node2, node3 with boot node', 'for i in 1 2 3; do', '  su - ubuntu -c "nohup ~/nearcore/target/release/neard --home ~/.near/localnet/node$i run --boot-nodes $BOOT_NODE > ~/neard-node$i.log 2>&1 &"', 'done', '', '# Wait for nodes to initialize', 'sleep 10', '', '# Validation: Check RPC status', 'echo "Validating NEAR node startup..."', 'for i in {1..30}; do', '  if curl -sS http://127.0.0.1:3030/status > /dev/null 2>&1; then', '    echo "RPC endpoint responding"', '    break', '  fi', '  if [ $i -eq 30 ]; then', '    echo "WARNING: RPC endpoint not responding after 30 attempts"', '  fi', '  sleep 2', 'done', '', '# Validation: Verify localnet account exists in genesis', 'if grep -q "\\"account_id\\": \\"localnet\\"" /home/ubuntu/.near/localnet/node0/genesis.json; then', '  echo "✅ Genesis contains localnet account"', 'else', '  echo "❌ ERROR: Genesis does not contain localnet account"', '  exit 1', 'fi', '', 'echo "NEAR localnet initialization complete with localnet root account" > /var/log/near-init-complete.log');
        // Create EC2 instance (following working chain-mobil implementation)
        // Changed ID to force replacement when version updates
        // Added timestamp suffix to force new instance creation for genesis modification
        this.instance = new ec2.Instance(this, `NearLocalnetNodeV${nearVersion.replace(/\./g, "")}Localnet`, {
            vpc: this.vpc,
            instanceType: ec2InstanceType,
            machineImage,
            securityGroup: this.securityGroup,
            role: this.instanceRole,
            userData, // Set UserData directly (following working chain-mobil implementation)
            vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC }, // For outbound internet (download Rust, nearcore)
            ssmSessionPermissions: true, // Enable SSM Session Manager
            // Increase root volume size for Rust compilation (default 8GB is too small)
            blockDevices: [{
                    deviceName: "/dev/sda1", // Ubuntu root device
                    volume: ec2.BlockDeviceVolume.ebs(dataVolume.sizeGiB, {
                        volumeType: ec2.EbsDeviceVolumeType.GP3,
                        deleteOnTermination: true,
                    }),
                }],
        });
        // Store the logical ID for cfn-signal
        const nodeCFLogicalId = this.instance.node.defaultChild?.node.id || "NearLocalnetNode";
        // Add version tag to force replacement when version changes
        cdk.Tags.of(this.instance).add("NearVersion", nearVersion);
        this.instanceId = this.instance.instanceId;
        // Stack outputs
        new cdk.CfnOutput(this, "near-instance-id", {
            value: this.instanceId,
            exportName: "NearLocalnetInstanceId",
        });
        new cdk.CfnOutput(this, "near-instance-private-ip", {
            value: this.instance.instancePrivateIp,
            exportName: "NearLocalnetInstancePrivateIp",
        });
        new cdk.CfnOutput(this, "near-instance-public-ip", {
            value: this.instance.instancePublicIp || "N/A",
            exportName: "NearLocalnetInstancePublicIp",
        });
        // Adding suppressions to the stack
        nag.NagSuppressions.addResourceSuppressions(this, [
            {
                id: "AwsSolutions-EC23",
                reason: "SSH access needed for debugging, RPC restricted to VPC",
            },
            {
                id: "AwsSolutions-EC26",
                reason: "EBS encryption not required for localnet development environment",
            },
            {
                id: "AwsSolutions-EC28",
                reason: "Detailed monitoring not required for localnet development environment",
            },
            {
                id: "AwsSolutions-EC29",
                reason: "Termination protection not required for localnet development environment",
            },
        ], true);
    }
}
exports.NearInfrastructureStack = NearInfrastructureStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5mcmFzdHJ1Y3R1cmUtc3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmZyYXN0cnVjdHVyZS1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpREFBbUM7QUFFbkMseURBQTJDO0FBRTNDLDZDQUErQjtBQWUvQixNQUFhLHVCQUF3QixTQUFRLEdBQUcsQ0FBQyxLQUFLO0lBT2xELFlBQVksS0FBOEIsRUFBRSxFQUFVLEVBQUUsS0FBbUM7UUFDdkYsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3pDLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNoRCxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFFNUMsTUFBTSxFQUNGLFlBQVksRUFDWixlQUFlLEVBQ2YsV0FBVyxFQUNYLFdBQVcsRUFDWCxVQUFVLEVBQ1YsR0FBRyxFQUNILGFBQWEsRUFDYixZQUFZLEdBQ2YsR0FBRyxLQUFLLENBQUM7UUFFVixtRUFBbUU7UUFDbkUsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQ2YsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7WUFDbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDckMsQ0FBQzthQUFNLENBQUM7WUFDSixxRkFBcUY7WUFDckYsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FB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aW1wb3J0ICogYXMgY2RrIGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuaW1wb3J0ICogYXMgY2RrQ29uc3RydWN0cyBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0ICogYXMgZWMyIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtZWMyXCI7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1pYW1cIjtcbmltcG9ydCAqIGFzIG5hZyBmcm9tIFwiY2RrLW5hZ1wiO1xuaW1wb3J0ICogYXMgY29uZmlnVHlwZXMgZnJvbSBcIi4vY29uZmlnL25vZGUtY29uZmlnLmludGVyZmFjZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5lYXJJbmZyYXN0cnVjdHVyZVN0YWNrUHJvcHMgZXh0ZW5kcyBjZGsuU3RhY2tQcm9wcyB7XG4gICAgaW5zdGFuY2VUeXBlOiBzdHJpbmc7XG4gICAgaW5zdGFuY2VDcHVUeXBlOiBcIng4Nl82NFwiIHwgXCJhcm02NFwiO1xuICAgIG5lYXJOZXR3b3JrOiBjb25maWdUeXBlcy5OZWFyTmV0d29yaztcbiAgICBuZWFyVmVyc2lvbjogc3RyaW5nO1xuICAgIGRhdGFWb2x1bWU6IGNvbmZpZ1R5cGVzLk5lYXJEYXRhVm9sdW1lQ29uZmlnO1xuICAgIGxpbWl0T3V0VHJhZmZpY01icHM6IG51bWJlcjtcbiAgICB2cGM/OiBlYzIuSVZwYztcbiAgICBzZWN1cml0eUdyb3VwPzogZWMyLklTZWN1cml0eUdyb3VwO1xuICAgIGluc3RhbmNlUm9sZT86IGlhbS5JUm9sZTtcbn1cblxuZXhwb3J0IGNsYXNzIE5lYXJJbmZyYXN0cnVjdHVyZVN0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgaW5zdGFuY2VJZDogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBpbnN0YW5jZTogZWMyLkluc3RhbmNlO1xuICAgIHB1YmxpYyByZWFkb25seSBpbnN0YW5jZVJvbGU6IGlhbS5JUm9sZTtcbiAgICBwdWJsaWMgcmVhZG9ubHkgdnBjOiBlYzIuSVZwYztcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VjdXJpdHlHcm91cDogZWMyLklTZWN1cml0eUdyb3VwO1xuXG4gICAgY29uc3RydWN0b3Ioc2NvcGU6IGNka0NvbnN0cnVjdHMuQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogTmVhckluZnJhc3RydWN0dXJlU3RhY2tQcm9wcykge1xuICAgICAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgICAgICBjb25zdCBSRUdJT04gPSBjZGsuU3RhY2sub2YodGhpcykucmVnaW9uO1xuICAgICAgICBjb25zdCBTVEFDS19OQU1FID0gY2RrLlN0YWNrLm9mKHRoaXMpLnN0YWNrTmFtZTtcbiAgICAgICAgY29uc3QgU1RBQ0tfSUQgPSBjZGsuU3RhY2sub2YodGhpcykuc3RhY2tJZDtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbnN0YW5jZVR5cGUsXG4gICAgICAgICAgICBpbnN0YW5jZUNwdVR5cGUsXG4gICAgICAgICAgICBuZWFyTmV0d29yayxcbiAgICAgICAgICAgIG5lYXJWZXJzaW9uLFxuICAgICAgICAgICAgZGF0YVZvbHVtZSxcbiAgICAgICAgICAgIHZwYyxcbiAgICAgICAgICAgIHNlY3VyaXR5R3JvdXAsXG4gICAgICAgICAgICBpbnN0YW5jZVJvbGUsXG4gICAgICAgIH0gPSBwcm9wcztcblxuICAgICAgICAvLyBVc2UgcHJvdmlkZWQgVlBDL3NlY3VyaXR5IGdyb3VwL3JvbGUgb3IgaW1wb3J0IGZyb20gY29tbW9uIHN0YWNrXG4gICAgICAgIGlmICh2cGMgJiYgc2VjdXJpdHlHcm91cCAmJiBpbnN0YW5jZVJvbGUpIHtcbiAgICAgICAgICAgIHRoaXMudnBjID0gdnBjO1xuICAgICAgICAgICAgdGhpcy5zZWN1cml0eUdyb3VwID0gc2VjdXJpdHlHcm91cDtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VSb2xlID0gaW5zdGFuY2VSb2xlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gaW1wb3J0cyAoZm9yIGNyb3NzLXN0YWNrIHJlZmVyZW5jZXMgd2hlbiBzdGFja3MgYXJlIGluIGRpZmZlcmVudCBhcHBzKVxuICAgICAgICAgICAgY29uc3QgdnBjSWQgPSBjZGsuRm4uaW1wb3J0VmFsdWUoXCJOZWFyTG9jYWxuZXRWcGNJZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3VyaXR5R3JvdXBJZCA9IGNkay5Gbi5pbXBvcnRWYWx1ZShcIk5lYXJMb2NhbG5ldFNlY3VyaXR5R3JvdXBJZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkSW5zdGFuY2VSb2xlQXJuID0gY2RrLkZuLmltcG9ydFZhbHVlKFwiTmVhckxvY2FsbmV0SW5zdGFuY2VSb2xlQXJuXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBOb3RlOiBWcGMuZnJvbUxvb2t1cCByZXF1aXJlcyBlbnZpcm9ubWVudCBjb250ZXh0IGFuZCB3b24ndCB3b3JrIHdpdGggaW1wb3J0ZWQgdmFsdWVzXG4gICAgICAgICAgICAvLyBUaGlzIGZhbGxiYWNrIGlzIGZvciByZWZlcmVuY2UgYnV0IHNob3VsZCB1c2UgZGlyZWN0IHJlZmVyZW5jZXMgaW4gYXBwLnRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWUEMsIHNlY3VyaXR5IGdyb3VwLCBhbmQgaW5zdGFuY2Ugcm9sZSBtdXN0IGJlIHByb3ZpZGVkIGRpcmVjdGx5IHdoZW4gc3RhY2tzIGFyZSBpbiB0aGUgc2FtZSBhcHBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVYnVudHUgMjQuMDQgTFRTIGltYWdlIGZvciBhbWQ2NCAoeDg2XzY0IHJlcXVpcmVkIGZvciBORUFSKVxuICAgICAgICBsZXQgdWJ1bnR1U3RhYmxlSW1hZ2VTc21OYW1lID0gXCIvYXdzL3NlcnZpY2UvY2Fub25pY2FsL3VidW50dS9zZXJ2ZXIvMjQuMDQvc3RhYmxlL2N1cnJlbnQvYW1kNjQvaHZtL2Vicy1ncDMvYW1pLWlkXCI7XG4gICAgICAgIGlmIChpbnN0YW5jZUNwdVR5cGUgPT09IFwiYXJtNjRcIikge1xuICAgICAgICAgICAgdWJ1bnR1U3RhYmxlSW1hZ2VTc21OYW1lID0gXCIvYXdzL3NlcnZpY2UvY2Fub25pY2FsL3VidW50dS9zZXJ2ZXIvMjQuMDQvc3RhYmxlL2N1cnJlbnQvYXJtNjQvaHZtL2Vicy1ncDMvYW1pLWlkXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFjaGluZUltYWdlID0gZWMyLk1hY2hpbmVJbWFnZS5mcm9tU3NtUGFyYW1ldGVyKHVidW50dVN0YWJsZUltYWdlU3NtTmFtZSk7XG5cbiAgICAgICAgLy8gUGFyc2UgaW5zdGFuY2UgdHlwZSAtIENESyBleHBlY3RzIEluc3RhbmNlQ2xhc3MgZW51bSBhbmQgSW5zdGFuY2VTaXplIGVudW1cbiAgICAgICAgLy8gXCJ0My5sYXJnZVwiIC0+IEluc3RhbmNlQ2xhc3MuVDMsIEluc3RhbmNlU2l6ZS5MQVJHRVxuICAgICAgICBjb25zdCBbaW5zdGFuY2VDbGFzc1N0ciwgaW5zdGFuY2VTaXplU3RyXSA9IGluc3RhbmNlVHlwZS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgLy8gQ29udmVydCBcInQzXCIgLT4gXCJUM1wiIGZvciBJbnN0YW5jZUNsYXNzIGVudW1cbiAgICAgICAgY29uc3QgaW5zdGFuY2VDbGFzcyA9IChpbnN0YW5jZUNsYXNzU3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaW5zdGFuY2VDbGFzc1N0ci5zbGljZSgxKSkudG9VcHBlckNhc2UoKSBhcyBlYzIuSW5zdGFuY2VDbGFzcztcbiAgICAgICAgY29uc3QgaW5zdGFuY2VTaXplID0gaW5zdGFuY2VTaXplU3RyLnRvVXBwZXJDYXNlKCkgYXMgZWMyLkluc3RhbmNlU2l6ZTtcbiAgICAgICAgY29uc3QgZWMySW5zdGFuY2VUeXBlID0gbmV3IGVjMi5JbnN0YW5jZVR5cGUoYCR7aW5zdGFuY2VDbGFzc1N0cn0uJHtpbnN0YW5jZVNpemVTdHJ9YCk7XG5cbiAgICAgICAgLy8gVXNlckRhdGEgc2NyaXB0IGZvbGxvd2luZyB0aGUgd29ya2luZyBpbXBsZW1lbnRhdGlvbiBmcm9tIGNoYWluLW1vYmlsL2Nka1xuICAgICAgICAvLyBUaGlzIGNvbXBpbGVzIGFuZCBydW5zIG5lYXJkIG9uIFVidW50dSBwZXIgTkVBUidzIHJlY29tbWVuZGF0aW9uc1xuICAgICAgICAvLyBNb2RpZmllZCB0byBhZGQgbG9jYWxuZXQgcm9vdCBhY2NvdW50IHRvIGdlbmVzaXMgZm9yIC5sb2NhbG5ldCBuYW1pbmcgcGFyaXR5XG4gICAgICAgIC8vIEZvcmNlIHJlcGxhY2VtZW50OiAyMDI1LTEyLTMwVDA1OjM1OjAwWlxuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGVjMi5Vc2VyRGF0YS5mb3JMaW51eCgpO1xuICAgICAgICB1c2VyRGF0YS5hZGRDb21tYW5kcyhcbiAgICAgICAgICAgICcjIS9iaW4vYmFzaCcsXG4gICAgICAgICAgICAnc2V0IC1lJyxcbiAgICAgICAgICAgICdleGVjID4gPih0ZWUgL3Zhci9sb2cvbmVhci1zZXR1cC5sb2cpIDI+JjEnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBGb3JjZSByZXBsYWNlbWVudCB0aW1lc3RhbXA6IDIwMjUtMTItMzBUMDU6MzU6MDBaJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgVXBkYXRlIHN5c3RlbScsXG4gICAgICAgICAgICAnYXB0IHVwZGF0ZScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEluc3RhbGwgZGVwZW5kZW5jaWVzIGZvciBORUFSIGNvbXBpbGF0aW9uIChVYnVudHUgcGFja2FnZXMpJyxcbiAgICAgICAgICAgIC8vIE5PVEU6IFVidW50dSAyNC4wNCBubyBsb25nZXIgcHJvdmlkZXMgYW4gYGF3c2NsaWAgYXB0IGNhbmRpZGF0ZSBpbiBzb21lIGltYWdlcy9yZXBvcy5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgQVdTIENMSSB2aWEgcGlwIGJlbG93LlxuICAgICAgICAgICAgJ2FwdCBpbnN0YWxsIC15IGdpdCBiaW51dGlscy1kZXYgbGliY3VybDQtb3BlbnNzbC1kZXYgemxpYjFnLWRldiBsaWJkdy1kZXYgbGliaWJlcnR5LWRldiBjbWFrZSBnY2MgZysrIHB5dGhvbjMgcHl0aG9uMy1waXAgcHJvdG9idWYtY29tcGlsZXIgbGlic3NsLWRldiBwa2ctY29uZmlnIGNsYW5nIGxsdm0ganEnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBJbnN0YWxsIFJ1c3QgYXMgdWJ1bnR1IHVzZXInLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwiY3VybCAtLXByb3RvID1odHRwcyAtLXRsc3YxLjIgLXNTZiBodHRwczovL3NoLnJ1c3R1cC5ycyB8IHNoIC1zIC0tIC15XCInLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwic291cmNlIH4vLmNhcmdvL2VudiAmJiBydXN0YyAtLXZlcnNpb25cIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIENsb25lIG5lYXJjb3JlJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcImNkIH4gJiYgZ2l0IGNsb25lIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL25lYXJjb3JlLmdpdFwiJyxcbiAgICAgICAgICAgIGBzdSAtIHVidW50dSAtYyBcImNkIH4vbmVhcmNvcmUgJiYgZ2l0IGNoZWNrb3V0ICR7bmVhclZlcnNpb259XCJgLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBDb21waWxlIG5lYXJkICh0YWtlcyB+MTAtMTUgbWludXRlcyknLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwiY2Qgfi9uZWFyY29yZSAmJiBzb3VyY2Ugfi8uY2FyZ28vZW52ICYmIG1ha2UgbmVhcmRcIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEluc3RhbGwgbmVhcnVwIChVYnVudHUgMjQuMDQgcmVxdWlyZXMgLS1icmVhay1zeXN0ZW0tcGFja2FnZXMpJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcInBpcDMgaW5zdGFsbCAtLXVzZXIgLS1icmVhay1zeXN0ZW0tcGFja2FnZXMgbmVhcnVwXCInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBJbnN0YWxsIEFXUyBDTEkgKHJlcXVpcmVkIGZvciB3cml0aW5nIFNTTSBwYXJhbWV0ZXJzIGR1cmluZyBib290c3RyYXApJyxcbiAgICAgICAgICAgICdwaXAzIGluc3RhbGwgLS1icmVhay1zeXN0ZW0tcGFja2FnZXMgYXdzY2xpJyxcbiAgICAgICAgICAgICdhd3MgLS12ZXJzaW9uIHx8IHRydWUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBSdW4gbmVhcnVwIGxvY2FsbmV0IHdpdGggY29tcGlsZWQgYmluYXJ5IChjcmVhdGVzIGdlbmVzaXMuanNvbiknLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwiZXhwb3J0IFBBVEg9JFBBVEg6fi8ubG9jYWwvYmluICYmIG5lYXJ1cCBydW4gbG9jYWxuZXQgLS1iaW5hcnktcGF0aCB+L25lYXJjb3JlL3RhcmdldC9yZWxlYXNlXCIgPiAvdmFyL2xvZy9uZWFydXAubG9nIDI+JjEgJicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFdhaXQgZm9yIGdlbmVzaXMuanNvbiB0byBiZSBjcmVhdGVkIGJ5IG5lYXJ1cCcsXG4gICAgICAgICAgICAnZWNobyBcIldhaXRpbmcgZm9yIGdlbmVzaXMuanNvbiB0byBiZSBjcmVhdGVkLi4uXCInLFxuICAgICAgICAgICAgJ2ZvciBpIGluIHsxLi42MH07IGRvJyxcbiAgICAgICAgICAgICcgIGlmIFsgLWYgL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0L25vZGUwL2dlbmVzaXMuanNvbiBdOyB0aGVuJyxcbiAgICAgICAgICAgICcgICAgZWNobyBcIkdlbmVzaXMgZmlsZSBmb3VuZFwiJyxcbiAgICAgICAgICAgICcgICAgYnJlYWsnLFxuICAgICAgICAgICAgJyAgZmknLFxuICAgICAgICAgICAgJyAgc2xlZXAgMicsXG4gICAgICAgICAgICAnZG9uZScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFN0b3AgbmVhcnVwIGFuZCBhbGwgbmVhcmQgcHJvY2Vzc2VzIGJlZm9yZSBwYXRjaGluZyBnZW5lc2lzJyxcbiAgICAgICAgICAgICdlY2hvIFwiU3RvcHBpbmcgbmVhcnVwIGFuZCBuZWFyZCBwcm9jZXNzZXMuLi5cIicsXG4gICAgICAgICAgICAvLyBTdG9wIGFueSBydW5uaW5nIG5lYXJ1cC9uZWFyZCBwcm9jZXNzZXMgYmVmb3JlIHBhdGNoaW5nIGdlbmVzaXMuXG4gICAgICAgICAgICAvLyBSdW4gYXMgcm9vdCB0byBhdm9pZCBwZXJtaXNzaW9uIGlzc3VlcyAobmVhcnVwIGlzIHN0YXJ0ZWQgdmlhIGEgcm9vdC1vd25lZCBzdSB3cmFwcGVyKS5cbiAgICAgICAgICAgICdwa2lsbCAtZiBuZWFydXAgfHwgdHJ1ZScsXG4gICAgICAgICAgICAncGtpbGwgLWYgbmVhcmQgfHwgdHJ1ZScsXG4gICAgICAgICAgICAnc2xlZXAgNScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEdlbmVyYXRlIGxvY2FsbmV0IGtleXBhaXIgdXNpbmcgbmVhcmQgaW5pdCAod29ya3MgaW4gbmVhcmQgMi4xMC4xKScsXG4gICAgICAgICAgICAnZWNobyBcIkdlbmVyYXRpbmcgbG9jYWxuZXQga2V5cGFpciB1c2luZyBuZWFyZCBpbml0Li4uXCInLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwicm0gLXJmIH4vLm5lYXIvbG9jYWxuZXQta2V5Z2VuICYmIG1rZGlyIC1wIH4vLm5lYXIvbG9jYWxuZXQta2V5Z2VuXCInLFxuICAgICAgICAgICAgJ3N1IC0gdWJ1bnR1IC1jIFwifi9uZWFyY29yZS90YXJnZXQvcmVsZWFzZS9uZWFyZCAtLWhvbWUgfi8ubmVhci9sb2NhbG5ldC1rZXlnZW4gaW5pdCAtLWFjY291bnQtaWQgbG9jYWxuZXQgLS1jaGFpbi1pZCBsb2NhbG5ldCAtLWZhc3RcIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEV4dHJhY3QgcHVibGljIGFuZCBzZWNyZXQga2V5cyBmcm9tIHZhbGlkYXRvcl9rZXkuanNvbicsXG4gICAgICAgICAgICAnTE9DQUxORVRfS0VZX0ZJTEU9XCIvaG9tZS91YnVudHUvLm5lYXIvbG9jYWxuZXQta2V5Z2VuL3ZhbGlkYXRvcl9rZXkuanNvblwiJyxcbiAgICAgICAgICAgICdpZiBbICEgLWYgXCIkTE9DQUxORVRfS0VZX0ZJTEVcIiBdOyB0aGVuJyxcbiAgICAgICAgICAgICcgIGVjaG8gXCJFUlJPUjogdmFsaWRhdG9yX2tleS5qc29uIG5vdCBmb3VuZCBhZnRlciBuZWFyZCBpbml0XCInLFxuICAgICAgICAgICAgJyAgZXhpdCAxJyxcbiAgICAgICAgICAgICdmaScsXG4gICAgICAgICAgICAnTE9DQUxORVRfUFVCTElDX0tFWT0kKHN1IC0gdWJ1bnR1IC1jIFwiY2F0ICRMT0NBTE5FVF9LRVlfRklMRSB8IGpxIC1yIFxcJy5wdWJsaWNfa2V5XFwnXCIgMj4vZGV2L251bGwgfHwgZWNobyBcIlwiKScsXG4gICAgICAgICAgICAnTE9DQUxORVRfU0VDUkVUX0tFWT0kKHN1IC0gdWJ1bnR1IC1jIFwiY2F0ICRMT0NBTE5FVF9LRVlfRklMRSB8IGpxIC1yIFxcJy5zZWNyZXRfa2V5XFwnXCIgMj4vZGV2L251bGwgfHwgZWNobyBcIlwiKScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdpZiBbIC16IFwiJExPQ0FMTkVUX1BVQkxJQ19LRVlcIiBdIHx8IFsgLXogXCIkTE9DQUxORVRfU0VDUkVUX0tFWVwiIF0gfHwgWyBcIiRMT0NBTE5FVF9QVUJMSUNfS0VZXCIgPSBcIm51bGxcIiBdIHx8IFsgXCIkTE9DQUxORVRfU0VDUkVUX0tFWVwiID0gXCJudWxsXCIgXTsgdGhlbicsXG4gICAgICAgICAgICAnICBlY2hvIFwiRVJST1I6IENvdWxkIG5vdCBleHRyYWN0IGxvY2FsbmV0IGtleXMgZnJvbSB2YWxpZGF0b3Jfa2V5Lmpzb25cIicsXG4gICAgICAgICAgICAnICBleGl0IDEnLFxuICAgICAgICAgICAgJ2ZpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgQ3JlYXRlIFB5dGhvbiBzY3JpcHQgZm9yIGdlbmVzaXMgcGF0Y2hpbmcgd2l0aCByZWFsbG9jYXRpb24nLFxuICAgICAgICAgICAgJ2NhdCA+IC90bXAvcGF0Y2gtZ2VuZXNpcy1sb2NhbG5ldC5weSA8PCBcXCdQWUVPRlxcJycsXG4gICAgICAgICAgICAnIyEvdXNyL2Jpbi9lbnYgcHl0aG9uMycsXG4gICAgICAgICAgICAnaW1wb3J0IGpzb24nLFxuICAgICAgICAgICAgJ2ltcG9ydCBzeXMnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnaWYgbGVuKHN5cy5hcmd2KSAhPSA1OicsXG4gICAgICAgICAgICAnICAgIHByaW50KFwiVXNhZ2U6IHBhdGNoLWdlbmVzaXMtbG9jYWxuZXQucHkgPGdlbmVzaXMuanNvbj4gPHB1YmxpY19rZXk+IDx0cmFuc2Zlcl9hbW91bnQ+IDxvdXRwdXQuanNvbj5cIiknLFxuICAgICAgICAgICAgJyAgICBzeXMuZXhpdCgxKScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdnZW5lc2lzX3BhdGggPSBzeXMuYXJndlsxXScsXG4gICAgICAgICAgICAncHVibGljX2tleSA9IHN5cy5hcmd2WzJdJyxcbiAgICAgICAgICAgICd0cmFuc2Zlcl9hbW91bnQgPSBzeXMuYXJndlszXScsXG4gICAgICAgICAgICAnb3V0cHV0X3BhdGggPSBzeXMuYXJndls0XScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICd3aXRoIG9wZW4oZ2VuZXNpc19wYXRoLCBcXCdyXFwnKSBhcyBmOicsXG4gICAgICAgICAgICAnICAgIGdlbmVzaXMgPSBqc29uLmxvYWQoZiknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBGaW5kIG5vZGUwIEFjY291bnQgcmVjb3JkIGFuZCBzdWJ0cmFjdCB0cmFuc2Zlcl9hbW91bnQnLFxuICAgICAgICAgICAgJ25vZGUwX2ZvdW5kID0gRmFsc2UnLFxuICAgICAgICAgICAgJ2ZvciByZWNvcmQgaW4gZ2VuZXNpcy5nZXQoXFwncmVjb3Jkc1xcJywgW10pOicsXG4gICAgICAgICAgICAnICAgIGlmIFxcJ0FjY291bnRcXCcgaW4gcmVjb3JkOicsXG4gICAgICAgICAgICAnICAgICAgICBhY2NvdW50ID0gcmVjb3JkW1xcJ0FjY291bnRcXCddJyxcbiAgICAgICAgICAgICcgICAgICAgIGlmIGFjY291bnQuZ2V0KFxcJ2FjY291bnRfaWRcXCcpID09IFxcJ25vZGUwXFwnOicsXG4gICAgICAgICAgICAnICAgICAgICAgICAgbm9kZTBfZm91bmQgPSBUcnVlJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBjdXJyZW50X2Ftb3VudCA9IGludChhY2NvdW50W1xcJ2FjY291bnRcXCddW1xcJ2Ftb3VudFxcJ10pJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBuZXdfYW1vdW50ID0gY3VycmVudF9hbW91bnQgLSBpbnQodHJhbnNmZXJfYW1vdW50KScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgaWYgbmV3X2Ftb3VudCA8IDA6JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICAgICAgcHJpbnQoZlwiRVJST1I6IG5vZGUwIGJhbGFuY2UgKHtjdXJyZW50X2Ftb3VudH0pIGluc3VmZmljaWVudCBmb3IgdHJhbnNmZXIgKHt0cmFuc2Zlcl9hbW91bnR9KVwiKScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgICAgIHN5cy5leGl0KDEpJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBhY2NvdW50W1xcJ2FjY291bnRcXCddW1xcJ2Ftb3VudFxcJ10gPSBzdHIobmV3X2Ftb3VudCknLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIHByaW50KGZcIlJlYWxsb2NhdGVkIHt0cmFuc2Zlcl9hbW91bnR9IHlvY3RvTkVBUiBmcm9tIG5vZGUwIChuZXcgYmFsYW5jZToge25ld19hbW91bnR9KVwiKScsXG4gICAgICAgICAgICAnICAgICAgICAgICAgYnJlYWsnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnaWYgbm90IG5vZGUwX2ZvdW5kOicsXG4gICAgICAgICAgICAnICAgIHByaW50KFwiRVJST1I6IG5vZGUwIEFjY291bnQgcmVjb3JkIG5vdCBmb3VuZCBpbiBnZW5lc2lzXCIpJyxcbiAgICAgICAgICAgICcgICAgc3lzLmV4aXQoMSknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBBZGQgbG9jYWxuZXQgQWNjb3VudCByZWNvcmQnLFxuICAgICAgICAgICAgJ2xvY2FsbmV0X2FjY291bnRfcmVjb3JkID0geycsXG4gICAgICAgICAgICAnICAgIFwiQWNjb3VudFwiOiB7JyxcbiAgICAgICAgICAgICcgICAgICAgIFwiYWNjb3VudF9pZFwiOiBcImxvY2FsbmV0XCIsJyxcbiAgICAgICAgICAgICcgICAgICAgIFwiYWNjb3VudFwiOiB7JyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcImFtb3VudFwiOiB0cmFuc2Zlcl9hbW91bnQsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcImxvY2tlZFwiOiBcIjBcIiwnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIFwiY29kZV9oYXNoXCI6IFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIiwnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIFwic3RvcmFnZV91c2FnZVwiOiAxODIsJyxcbiAgICAgICAgICAgICcgICAgICAgICAgICBcInZlcnNpb25cIjogXCJWMVwiJyxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICdnZW5lc2lzW1xcJ3JlY29yZHNcXCddLmFwcGVuZChsb2NhbG5ldF9hY2NvdW50X3JlY29yZCknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBBZGQgbG9jYWxuZXQgQWNjZXNzS2V5IHJlY29yZCcsXG4gICAgICAgICAgICAnbG9jYWxuZXRfYWNjZXNzX2tleV9yZWNvcmQgPSB7JyxcbiAgICAgICAgICAgICcgICAgXCJBY2Nlc3NLZXlcIjogeycsXG4gICAgICAgICAgICAnICAgICAgICBcImFjY291bnRfaWRcIjogXCJsb2NhbG5ldFwiLCcsXG4gICAgICAgICAgICAnICAgICAgICBcInB1YmxpY19rZXlcIjogcHVibGljX2tleSwnLFxuICAgICAgICAgICAgJyAgICAgICAgXCJhY2Nlc3Nfa2V5XCI6IHsnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIFwibm9uY2VcIjogMCwnLFxuICAgICAgICAgICAgJyAgICAgICAgICAgIFwicGVybWlzc2lvblwiOiBcIkZ1bGxBY2Nlc3NcIicsXG4gICAgICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnZ2VuZXNpc1tcXCdyZWNvcmRzXFwnXS5hcHBlbmQobG9jYWxuZXRfYWNjZXNzX2tleV9yZWNvcmQpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ3dpdGggb3BlbihvdXRwdXRfcGF0aCwgXFwnd1xcJykgYXMgZjonLFxuICAgICAgICAgICAgJyAgICBqc29uLmR1bXAoZ2VuZXNpcywgZiwgaW5kZW50PTIpJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ3ByaW50KGZcIkdlbmVzaXMgcGF0Y2hlZCBzdWNjZXNzZnVsbHk6IHtvdXRwdXRfcGF0aH1cIiknLFxuICAgICAgICAgICAgJ1BZRU9GJyxcbiAgICAgICAgICAgICdjaG1vZCAreCAvdG1wL3BhdGNoLWdlbmVzaXMtbG9jYWxuZXQucHknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBQYXRjaCBnZW5lc2lzLmpzb24gd2l0aCByZWFsbG9jYXRpb24gZnJvbSBub2RlMCcsXG4gICAgICAgICAgICAnZWNobyBcIlBhdGNoaW5nIGdlbmVzaXMuanNvbiB3aXRoIGxvY2FsbmV0IGFjY291bnQgKHJlYWxsb2NhdGluZyBmcm9tIG5vZGUwKS4uLlwiJyxcbiAgICAgICAgICAgICdHRU5FU0lTX1BBVEg9XCIvaG9tZS91YnVudHUvLm5lYXIvbG9jYWxuZXQvbm9kZTAvZ2VuZXNpcy5qc29uXCInLFxuICAgICAgICAgICAgJ0FNT1VOVD1cIjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiICAjIDEwMCwwMDAgTkVBUicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEJhY2t1cCBnZW5lc2lzJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcImNwICRHRU5FU0lTX1BBVEggJHtHRU5FU0lTX1BBVEh9LmJhY2t1cC4kKGRhdGUgKyVzKVwiJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgUnVuIFB5dGhvbiBzY3JpcHQgdG8gcGF0Y2ggZ2VuZXNpcycsXG4gICAgICAgICAgICAncHl0aG9uMyAvdG1wL3BhdGNoLWdlbmVzaXMtbG9jYWxuZXQucHkgXCIkR0VORVNJU19QQVRIXCIgXCIkTE9DQUxORVRfUFVCTElDX0tFWVwiIFwiJEFNT1VOVFwiIC90bXAvZ2VuZXNpc19wYXRjaGVkLmpzb24nLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBSZXBsYWNlIGdlbmVzaXMgZm9yIGFsbCBub2RlcycsXG4gICAgICAgICAgICAnZm9yIG5vZGUgaW4gbm9kZTAgbm9kZTEgbm9kZTIgbm9kZTM7IGRvJyxcbiAgICAgICAgICAgICcgIGlmIFsgLWQgL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0LyRub2RlIF07IHRoZW4nLFxuICAgICAgICAgICAgJyAgICBzdSAtIHVidW50dSAtYyBcImNwIC90bXAvZ2VuZXNpc19wYXRjaGVkLmpzb24gL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0LyRub2RlL2dlbmVzaXMuanNvblwiJyxcbiAgICAgICAgICAgICcgICAgZWNobyBcIlVwZGF0ZWQgZ2VuZXNpcyBmb3IgJG5vZGVcIicsXG4gICAgICAgICAgICAnICBmaScsXG4gICAgICAgICAgICAnZG9uZScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFJlbW92ZSBub2RlIGRhdGEgZGlyZWN0b3JpZXMgc28gbm9kZXMgc3RhcnQgY2xlYW5seSB3aXRoIHBhdGNoZWQgZ2VuZXNpcycsXG4gICAgICAgICAgICAnZWNobyBcIlJlbW92aW5nIG5vZGUgZGF0YSBkaXJlY3RvcmllcyBmb3IgY2xlYW4gc3RhcnQuLi5cIicsXG4gICAgICAgICAgICAnZm9yIG5vZGUgaW4gbm9kZTAgbm9kZTEgbm9kZTIgbm9kZTM7IGRvJyxcbiAgICAgICAgICAgICcgIGlmIFsgLWQgL2hvbWUvdWJ1bnR1Ly5uZWFyL2xvY2FsbmV0LyRub2RlL2RhdGEgXTsgdGhlbicsXG4gICAgICAgICAgICAnICAgIHN1IC0gdWJ1bnR1IC1jIFwicm0gLXJmIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC8kbm9kZS9kYXRhXCInLFxuICAgICAgICAgICAgJyAgICBlY2hvIFwiUmVtb3ZlZCBkYXRhIGRpcmVjdG9yeSBmb3IgJG5vZGVcIicsXG4gICAgICAgICAgICAnICBmaScsXG4gICAgICAgICAgICAnZG9uZScsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFN0b3JlIGxvY2FsbmV0IGtleXBhaXIgaW4gU1NNIFBhcmFtZXRlciBTdG9yZScsXG4gICAgICAgICAgICAnZWNobyBcIlN0b3JpbmcgbG9jYWxuZXQga2V5cGFpciBpbiBTU00uLi5cIicsXG4gICAgICAgICAgICAnIyBJTURTdjItc2FmZSByZWdpb24gZGlzY292ZXJ5JyxcbiAgICAgICAgICAgICdUT0tFTj0kKGN1cmwgLXNTIC1YIFBVVCBcImh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvbGF0ZXN0L2FwaS90b2tlblwiIC1IIFwiWC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuLXR0bC1zZWNvbmRzOiAyMTYwMFwiIHx8IHRydWUpJyxcbiAgICAgICAgICAgICdpZiBbIC1uIFwiJFRPS0VOXCIgXTsgdGhlbicsXG4gICAgICAgICAgICAnICBBV1NfUkVHSU9OPSQoY3VybCAtc1MgLUggXCJYLWF3cy1lYzItbWV0YWRhdGEtdG9rZW46ICRUT0tFTlwiIGh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvbGF0ZXN0L21ldGEtZGF0YS9wbGFjZW1lbnQvcmVnaW9uKScsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAnICBBV1NfUkVHSU9OPSQoY3VybCAtc1MgaHR0cDovLzE2OS4yNTQuMTY5LjI1NC9sYXRlc3QvbWV0YS1kYXRhL3BsYWNlbWVudC9yZWdpb24pJyxcbiAgICAgICAgICAgICdmaScsXG4gICAgICAgICAgICAnYXdzIHNzbSBwdXQtcGFyYW1ldGVyIC0tbmFtZSBcIi9uZWFyLWxvY2FsbmV0L2xvY2FsbmV0LWFjY291bnQta2V5XCIgLS12YWx1ZSBcIiRMT0NBTE5FVF9TRUNSRVRfS0VZXCIgLS10eXBlIFwiU2VjdXJlU3RyaW5nXCIgLS1vdmVyd3JpdGUgLS1yZWdpb24gXCIkQVdTX1JFR0lPTlwiIHx8IHRydWUnLFxuICAgICAgICAgICAgJ2F3cyBzc20gcHV0LXBhcmFtZXRlciAtLW5hbWUgXCIvbmVhci1sb2NhbG5ldC9sb2NhbG5ldC1hY2NvdW50LWlkXCIgLS12YWx1ZSBcImxvY2FsbmV0XCIgLS10eXBlIFwiU3RyaW5nXCIgLS1vdmVyd3JpdGUgLS1yZWdpb24gXCIkQVdTX1JFR0lPTlwiIHx8IHRydWUnLFxuICAgICAgICAgICAgJ2VjaG8gXCJMb2NhbG5ldCBrZXlwYWlyIHN0b3JlZCBpbiBTU01cIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFN0YXJ0IG5lYXJkIHByb2Nlc3NlcyBkaXJlY3RseSAobm90IHZpYSBuZWFydXApJyxcbiAgICAgICAgICAgICdlY2hvIFwiU3RhcnRpbmcgbmVhcmQgcHJvY2Vzc2VzIHdpdGggcGF0Y2hlZCBnZW5lc2lzLi4uXCInLFxuICAgICAgICAgICAgJyMgR2V0IG5vZGUwIGJvb3Qgbm9kZSBwdWJsaWMga2V5JyxcbiAgICAgICAgICAgICdCT09UX1BVQj0kKHN1IC0gdWJ1bnR1IC1jIFwiY2F0IH4vLm5lYXIvbG9jYWxuZXQvbm9kZTAvbm9kZV9rZXkuanNvbiB8IGpxIC1yIFxcJy5wdWJsaWNfa2V5XFwnXCIpJyxcbiAgICAgICAgICAgICdCT09UX05PREU9XCIke0JPT1RfUFVCfUAxMjcuMC4wLjE6MjQ1NjdcIicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFN0YXJ0IG5vZGUwJyxcbiAgICAgICAgICAgICdzdSAtIHVidW50dSAtYyBcIm5vaHVwIH4vbmVhcmNvcmUvdGFyZ2V0L3JlbGVhc2UvbmVhcmQgLS1ob21lIH4vLm5lYXIvbG9jYWxuZXQvbm9kZTAgcnVuID4gfi9uZWFyZC1ub2RlMC5sb2cgMj4mMSAmXCInLFxuICAgICAgICAgICAgJ3NsZWVwIDInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBTdGFydCBub2RlMSwgbm9kZTIsIG5vZGUzIHdpdGggYm9vdCBub2RlJyxcbiAgICAgICAgICAgICdmb3IgaSBpbiAxIDIgMzsgZG8nLFxuICAgICAgICAgICAgJyAgc3UgLSB1YnVudHUgLWMgXCJub2h1cCB+L25lYXJjb3JlL3RhcmdldC9yZWxlYXNlL25lYXJkIC0taG9tZSB+Ly5uZWFyL2xvY2FsbmV0L25vZGUkaSBydW4gLS1ib290LW5vZGVzICRCT09UX05PREUgPiB+L25lYXJkLW5vZGUkaS5sb2cgMj4mMSAmXCInLFxuICAgICAgICAgICAgJ2RvbmUnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBXYWl0IGZvciBub2RlcyB0byBpbml0aWFsaXplJyxcbiAgICAgICAgICAgICdzbGVlcCAxMCcsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIFZhbGlkYXRpb246IENoZWNrIFJQQyBzdGF0dXMnLFxuICAgICAgICAgICAgJ2VjaG8gXCJWYWxpZGF0aW5nIE5FQVIgbm9kZSBzdGFydHVwLi4uXCInLFxuICAgICAgICAgICAgJ2ZvciBpIGluIHsxLi4zMH07IGRvJyxcbiAgICAgICAgICAgICcgIGlmIGN1cmwgLXNTIGh0dHA6Ly8xMjcuMC4wLjE6MzAzMC9zdGF0dXMgPiAvZGV2L251bGwgMj4mMTsgdGhlbicsXG4gICAgICAgICAgICAnICAgIGVjaG8gXCJSUEMgZW5kcG9pbnQgcmVzcG9uZGluZ1wiJyxcbiAgICAgICAgICAgICcgICAgYnJlYWsnLFxuICAgICAgICAgICAgJyAgZmknLFxuICAgICAgICAgICAgJyAgaWYgWyAkaSAtZXEgMzAgXTsgdGhlbicsXG4gICAgICAgICAgICAnICAgIGVjaG8gXCJXQVJOSU5HOiBSUEMgZW5kcG9pbnQgbm90IHJlc3BvbmRpbmcgYWZ0ZXIgMzAgYXR0ZW1wdHNcIicsXG4gICAgICAgICAgICAnICBmaScsXG4gICAgICAgICAgICAnICBzbGVlcCAyJyxcbiAgICAgICAgICAgICdkb25lJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgVmFsaWRhdGlvbjogVmVyaWZ5IGxvY2FsbmV0IGFjY291bnQgZXhpc3RzIGluIGdlbmVzaXMnLFxuICAgICAgICAgICAgJ2lmIGdyZXAgLXEgXCJcXFxcXCJhY2NvdW50X2lkXFxcXFwiOiBcXFxcXCJsb2NhbG5ldFxcXFxcIlwiIC9ob21lL3VidW50dS8ubmVhci9sb2NhbG5ldC9ub2RlMC9nZW5lc2lzLmpzb247IHRoZW4nLFxuICAgICAgICAgICAgJyAgZWNobyBcIuKchSBHZW5lc2lzIGNvbnRhaW5zIGxvY2FsbmV0IGFjY291bnRcIicsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAnICBlY2hvIFwi4p2MIEVSUk9SOiBHZW5lc2lzIGRvZXMgbm90IGNvbnRhaW4gbG9jYWxuZXQgYWNjb3VudFwiJyxcbiAgICAgICAgICAgICcgIGV4aXQgMScsXG4gICAgICAgICAgICAnZmknLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnZWNobyBcIk5FQVIgbG9jYWxuZXQgaW5pdGlhbGl6YXRpb24gY29tcGxldGUgd2l0aCBsb2NhbG5ldCByb290IGFjY291bnRcIiA+IC92YXIvbG9nL25lYXItaW5pdC1jb21wbGV0ZS5sb2cnXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIEVDMiBpbnN0YW5jZSAoZm9sbG93aW5nIHdvcmtpbmcgY2hhaW4tbW9iaWwgaW1wbGVtZW50YXRpb24pXG4gICAgICAgIC8vIENoYW5nZWQgSUQgdG8gZm9yY2UgcmVwbGFjZW1lbnQgd2hlbiB2ZXJzaW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gQWRkZWQgdGltZXN0YW1wIHN1ZmZpeCB0byBmb3JjZSBuZXcgaW5zdGFuY2UgY3JlYXRpb24gZm9yIGdlbmVzaXMgbW9kaWZpY2F0aW9uXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgZWMyLkluc3RhbmNlKHRoaXMsIGBOZWFyTG9jYWxuZXROb2RlViR7bmVhclZlcnNpb24ucmVwbGFjZSgvXFwuL2csIFwiXCIpfUxvY2FsbmV0YCwge1xuICAgICAgICAgICAgdnBjOiB0aGlzLnZwYyxcbiAgICAgICAgICAgIGluc3RhbmNlVHlwZTogZWMySW5zdGFuY2VUeXBlLFxuICAgICAgICAgICAgbWFjaGluZUltYWdlLFxuICAgICAgICAgICAgc2VjdXJpdHlHcm91cDogdGhpcy5zZWN1cml0eUdyb3VwLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5pbnN0YW5jZVJvbGUsXG4gICAgICAgICAgICB1c2VyRGF0YSwgLy8gU2V0IFVzZXJEYXRhIGRpcmVjdGx5IChmb2xsb3dpbmcgd29ya2luZyBjaGFpbi1tb2JpbCBpbXBsZW1lbnRhdGlvbilcbiAgICAgICAgICAgIHZwY1N1Ym5ldHM6IHsgc3VibmV0VHlwZTogZWMyLlN1Ym5ldFR5cGUuUFVCTElDIH0sIC8vIEZvciBvdXRib3VuZCBpbnRlcm5ldCAoZG93bmxvYWQgUnVzdCwgbmVhcmNvcmUpXG4gICAgICAgICAgICBzc21TZXNzaW9uUGVybWlzc2lvbnM6IHRydWUsIC8vIEVuYWJsZSBTU00gU2Vzc2lvbiBNYW5hZ2VyXG4gICAgICAgICAgICAvLyBJbmNyZWFzZSByb290IHZvbHVtZSBzaXplIGZvciBSdXN0IGNvbXBpbGF0aW9uIChkZWZhdWx0IDhHQiBpcyB0b28gc21hbGwpXG4gICAgICAgICAgICBibG9ja0RldmljZXM6IFt7XG4gICAgICAgICAgICAgICAgZGV2aWNlTmFtZTogXCIvZGV2L3NkYTFcIiwgLy8gVWJ1bnR1IHJvb3QgZGV2aWNlXG4gICAgICAgICAgICAgICAgdm9sdW1lOiBlYzIuQmxvY2tEZXZpY2VWb2x1bWUuZWJzKGRhdGFWb2x1bWUuc2l6ZUdpQiwge1xuICAgICAgICAgICAgICAgICAgICB2b2x1bWVUeXBlOiBlYzIuRWJzRGV2aWNlVm9sdW1lVHlwZS5HUDMsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZU9uVGVybWluYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGxvZ2ljYWwgSUQgZm9yIGNmbi1zaWduYWxcbiAgICAgICAgY29uc3Qgbm9kZUNGTG9naWNhbElkID0gdGhpcy5pbnN0YW5jZS5ub2RlLmRlZmF1bHRDaGlsZD8ubm9kZS5pZCB8fCBcIk5lYXJMb2NhbG5ldE5vZGVcIjtcblxuICAgICAgICAvLyBBZGQgdmVyc2lvbiB0YWcgdG8gZm9yY2UgcmVwbGFjZW1lbnQgd2hlbiB2ZXJzaW9uIGNoYW5nZXNcbiAgICAgICAgY2RrLlRhZ3Mub2YodGhpcy5pbnN0YW5jZSkuYWRkKFwiTmVhclZlcnNpb25cIiwgbmVhclZlcnNpb24pO1xuXG4gICAgICAgIHRoaXMuaW5zdGFuY2VJZCA9IHRoaXMuaW5zdGFuY2UuaW5zdGFuY2VJZDtcblxuICAgICAgICAvLyBTdGFjayBvdXRwdXRzXG4gICAgICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsIFwibmVhci1pbnN0YW5jZS1pZFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgZXhwb3J0TmFtZTogXCJOZWFyTG9jYWxuZXRJbnN0YW5jZUlkXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsIFwibmVhci1pbnN0YW5jZS1wcml2YXRlLWlwXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmluc3RhbmNlLmluc3RhbmNlUHJpdmF0ZUlwLFxuICAgICAgICAgICAgZXhwb3J0TmFtZTogXCJOZWFyTG9jYWxuZXRJbnN0YW5jZVByaXZhdGVJcFwiLFxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCBcIm5lYXItaW5zdGFuY2UtcHVibGljLWlwXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmluc3RhbmNlLmluc3RhbmNlUHVibGljSXAgfHwgXCJOL0FcIixcbiAgICAgICAgICAgIGV4cG9ydE5hbWU6IFwiTmVhckxvY2FsbmV0SW5zdGFuY2VQdWJsaWNJcFwiLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGRpbmcgc3VwcHJlc3Npb25zIHRvIHRoZSBzdGFja1xuICAgICAgICBuYWcuTmFnU3VwcHJlc3Npb25zLmFkZFJlc291cmNlU3VwcHJlc3Npb25zKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcIkF3c1NvbHV0aW9ucy1FQzIzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJTU0ggYWNjZXNzIG5lZWRlZCBmb3IgZGVidWdnaW5nLCBSUEMgcmVzdHJpY3RlZCB0byBWUENcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwiQXdzU29sdXRpb25zLUVDMjZcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkVCUyBlbmNyeXB0aW9uIG5vdCByZXF1aXJlZCBmb3IgbG9jYWxuZXQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwiQXdzU29sdXRpb25zLUVDMjhcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkRldGFpbGVkIG1vbml0b3Jpbmcgbm90IHJlcXVpcmVkIGZvciBsb2NhbG5ldCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogXCJBd3NTb2x1dGlvbnMtRUMyOVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiVGVybWluYXRpb24gcHJvdGVjdGlvbiBub3QgcmVxdWlyZWQgZm9yIGxvY2FsbmV0IGRldmVsb3BtZW50IGVudmlyb25tZW50XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4iXX0=