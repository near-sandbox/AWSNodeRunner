---
description: TypeScript coding standards and conventions for this project
globs:
  - "**/*.ts"
  - "**/*.tsx"
alwaysApply: true
---

# TypeScript Standards and Conventions

Follow these TypeScript conventions to maintain code quality and consistency.

## TypeScript Configuration

This project uses strict TypeScript with these key settings:
- `strict: true`
- `noImplicitAny: true`
- `strictNullChecks: true`
- `noImplicitReturns: true`
- `declaration: true` (generates `.d.ts` files)
- `experimentalDecorators: true` (for CDK)

Reference: @tsconfig.json

## Import Conventions

### AWS CDK Imports

- Use namespace imports for CDK modules: `import * as cdk from "aws-cdk-lib"`
- Use specific imports for sub-modules: `import * as ec2 from "aws-cdk-lib/aws-ec2"`
- Use `import * as constructs from "constructs"` for Construct base types

**Preferred:**
```typescript
import * as cdk from "aws-cdk-lib";
import * as ec2 from "aws-cdk-lib/aws-ec2";
import * as iam from "aws-cdk-lib/aws-iam";
```

### Local Imports

- Use relative imports with explicit extensions: `./config/localnet-config`
- Group imports: external packages, CDK, then local files
- Use namespace imports for config modules: `import * as config from "./config/localnet-config"`

### Type Imports

- Import types from interfaces: `import * as configTypes from "./config/node-config.interface"`
- Use type-only imports when appropriate: `import type { SomeType } from "./types"`

## Type Definitions

### Interface Patterns

- Create explicit interfaces for all stack props extending `cdk.StackProps`
- Use types from `config/node-config.interface.ts` for configuration
- Export interfaces for reuse across stacks

**Pattern:**
```typescript
export interface NearInfrastructureStackProps extends cdk.StackProps {
    instanceType: string;
    instanceCpuType: "x86_64" | "arm64";
    nearNetwork: configTypes.NearNetwork;
    // ...
}
```

### Type Assertions

- Use `as` type assertions sparingly and only when necessary
- Prefer type guards and proper type narrowing
- Document why assertions are needed

**Example:**
```typescript
const instanceClass = instanceClassStr.toUpperCase() as ec2.InstanceClass;
```

## Variable Naming

- **Constants**: `UPPER_SNAKE_CASE` for module-level constants
- **Stack variables**: `camelCase` for local variables
- **CDK constructs**: `PascalCase` matching CloudFormation logical IDs
- **AWS resource names**: Match AWS conventions (e.g., `vpc`, `securityGroup`)

**Pattern:**
```typescript
const REGION = cdk.Stack.of(this).region;
const STACK_NAME = cdk.Stack.of(this).stackName;
const vpc = new ec2.Vpc(this, "NearVpc");
```

## Function and Method Patterns

### Constructor Patterns

- Destructure props in constructors
- Extract common values (region, stack name) at constructor start
- Validate required props and provide defaults where appropriate

**Pattern:**
```typescript
constructor(scope: cdkConstructs.Construct, id: string, props: NearStackProps) {
    super(scope, id, props);
    
    const REGION = cdk.Stack.of(this).region;
    const STACK_NAME = cdk.Stack.of(this).stackName;
    
    const { instanceType, nearNetwork, vpc } = props;
    // ...
}
```

### Error Handling

- Use descriptive error messages
- Throw errors for invalid configurations early
- Document expected error conditions

## Code Organization

### File Structure

- One class per file
- Co-locate related types and interfaces
- Group exports at the end of files

### Comments and Documentation

- Use JSDoc comments for public classes and methods
- Document complex logic and AWS-specific patterns
- Include context about NEAR-specific requirements

**Pattern:**
```typescript
/**
 * NEAR Localnet Infrastructure Stack
 * 
 * Creates EC2 instance and compiles NEAR node software.
 * Uses cfn-signal to signal completion.
 */
export class NearInfrastructureStack extends cdk.Stack {
    // ...
}
```

## Type Safety

### Null and Undefined Handling

- Enable `strictNullChecks: true`
- Use optional chaining: `stack.node.defaultChild?.node.id`
- Provide fallbacks: `process.env.AWS_REGION || "us-east-1"`

### Enum Usage

- Use string literal union types for configuration: `"x86_64" | "arm64"`
- Use CDK enums where available: `ec2.InstanceClass`, `ec2.InstanceSize`
- Convert strings to enums when parsing: `instanceClassStr.toUpperCase() as ec2.InstanceClass`

## Compilation and Build

- Always run `npm run build` before deployment
- Use `npm run watch` during development
- Generated files go to `dist/` directory
- Keep generated `.d.ts` files in version control

## Scripts

### TypeScript Scripts

- Use `ts-node` for TypeScript scripts: `node -r ts-node/register scripts/trigger-tests.ts`
- Build before running compiled scripts: `npm run build && node dist/scripts/export-config.js`

Reference: @package.json scripts section.